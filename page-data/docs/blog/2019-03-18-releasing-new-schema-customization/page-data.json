{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2019-03-18-releasing-new-schema-customization/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"67585e4b-3d01-5101-8ce0-f57598ca115a","excerpt":"Two weeks ago, we announced our plans for a new schema customization API. Today we are making this set of new APIs and enhancements available to all in @. First‚Ä¶","html":"<p>Two weeks ago, we announced our plans for a <a href=\"/gatsby-bloga-2/blog/2019-03-04-new-schema-customization/\">new schema customization API</a>. Today we are making this set of new APIs and enhancements available to all in <code class=\"language-text\">gatsby</code>@<code class=\"language-text\">2.2.0</code>.</p>\n<p>First, install the latest and greatest version of <code class=\"language-text\">gatsby</code>, like so:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> gatsby --save</code></pre></div>\n<p>Next, continue reading below to see if any of the great, new features we‚Äôve enabled scratch a particular itch. We feel very confident they will üíú</p>\n<h2>Recap of schema customization</h2>\n<p>Before this change, the Gatsby GraphQL schema was generated automatically from the data that the user added to Gatsby. While very convenient and easy to start, changes to the data could cause changes to the schema, which could cause breakage in unrelated locations. Those bugs were confusing and hard to debug. To alleviate this problem, we‚Äôve added a schema customization API that lets you customize, fix, and enhance types in your Gatsby GraphQL schema.</p>\n<p>There are two new APIs, <code class=\"language-text\">createTypes</code> and <code class=\"language-text\">createResolvers</code>.</p>\n<h3><code class=\"language-text\">createTypes</code></h3>\n<p><code class=\"language-text\">createTypes</code> can be used to define, fix, or extend a Gatsby GraphQL type that represents some of your app‚Äôs data. Think of it like an escape hatch to politely inform Gatsby of your data‚Äôs shape.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">exports.sourceNodes = ({ actions }) =&gt; {\n  const { createTypes } = actions\n  const typeDefs = `\n    type AuthorJson implements Node {\n      name: String\n      birthday: Date\n    }\n  `\n  createTypes(typeDefs)\n}</code></pre></div>\n<p>After adding this to your <a href=\"/gatsby-bloga-2/docs/gatsby-project-structure/#files\">gatsby-node</a> file, the <code class=\"language-text\">AuthorJson</code> type will always have fields name and birthday, regardless of the automatically inferred data shape. The rest of the fields will still be inferred normally, allowing you to enjoy the default benefits of Gatsby schema inference.</p>\n<h3><code class=\"language-text\">createResolvers</code></h3>\n<p><code class=\"language-text\">createResolvers</code> allows doing additional customization after all schema processing has been finished. Thus it can be used to add fields to any types, including root types like <code class=\"language-text\">Query</code> and types from third party schemas.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">createResolvers({\n  Query: {\n    allAuthorFullNames: {\n      type: `[String!]!`,\n      resolve(source, args, context, info) {\n        const authors = context.nodeModel.getAllNodes({\n          type: `AuthorJson`,\n        })\n        return authors.map(author =&gt; author.name)\n      },\n    },\n  },\n})</code></pre></div>\n<h3>The Type Builder API</h3>\n<p>While <code class=\"language-text\">createTypes</code> accepts GraphQL types as a <a href=\"https://graphql.org/learn/schema/\">Schema Definition Language (SDL)</a> string, we‚Äôve also added an option to use <code class=\"language-text\">graphql-js</code> types so that users could create types with resolvers. However, <code class=\"language-text\">graphql-js</code> is somewhat verbose and it can be hard to refer to types that don‚Äôt yet exist or don‚Äôt exist in a current scope. Therefore, we decided to add another programmatic API that combines brevity of SDL with flexibility of <code class=\"language-text\">graphql-js</code>.</p>\n<p>We refer to this API as the <em>Type Builder API</em>. It is available in the <code class=\"language-text\">schema</code> field of the arguments object passed to <a href=\"/gatsby-bloga-2/docs/node-apis/\">Gatsby Node APIs</a>.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">exports.sourceNodes = ({ actions, schema }) =&gt; {\n  const { createTypes } = actions\n  createTypes([\n    schema.buildObjectType({\n      name: `CommentJson`,\n      fields: {\n        text: `String!`,\n        blog: {\n          type: `BlogJson`,\n          resolve(parent, args, context) {\n            return context.nodeModel.getNodeById({\n              id: parent.author,\n              type: `BlogJson`,\n            })\n          },\n        },\n        author: {\n          type: `AuthorJson`,\n          resolve(parent, args, context) {\n            return context.nodeModel.getNodeById({\n              id: parent.author,\n              type: `AuthorJson`,\n            })\n          },\n        },\n      },\n      interfaces: [`Node`],\n    }),\n  ])\n}</code></pre></div>\n<h2>Potential for Breaking Changes</h2>\n<p>We have tried to avoid any breaking changes in this refactor of the underlying GraphQL layer, testing it in notable Gatsby sites and ensuring all tests were passing. However, there are areas where we needed to introduce more stable naming, and in these instances it <em>could</em> be possible that a breaking change was introduced if you were relying on this undocumented API.</p>\n<p>Specifically, before this refactor Gatsby type names weren‚Äôt stable. They could have names like <code class=\"language-text\">frontmatter_2</code> because of some quirks in our schema generation. Now the types names are <strong>stable</strong> and <strong>defined</strong>. For a <code class=\"language-text\">Node</code>, it‚Äôs always a Pascal Camel Cased name of the <code class=\"language-text\">Node</code> type (for example, <code class=\"language-text\">MarkdownRemark</code>). For an inline object, it‚Äôs the name of the node plus the name of the field, again Pascal Camel Cased. So <code class=\"language-text\">frontmatter_2</code> would be available as <code class=\"language-text\">MarkdownRemarkFrontmatter</code> now. If you‚Äôve had fragments referring to some types by their old names, you may need to change it to new names, e.g.:</p>\n<div class=\"gatsby-highlight\" data-language=\"diff\"><pre class=\"language-diff\"><code class=\"language-diff\"><span class=\"token deleted-sign deleted\">- fragment someFragment on frontmatter_2 {\n</span><span class=\"token inserted-sign inserted\">+ fragment someFragment on MarkdownRemarkFrontmatter {\n</span><span class=\"token unchanged\">  title\n</span>}</code></pre></div>\n<p>Another change relates to inference. Previously, ordering of the Nodes in your data source could affect which type Gatsby inferred. Now, we always consider all possible types, thus you might experience type conflicts for conflicting data sources. They can be solved by either fixing the data or defining a type using new schema customization APIs that we‚Äôve exposed.</p>\n<h2>Wrap-up</h2>\n<p>As next steps, we will work on adding more convenient tooling to ‚Äúfreeze‚Äù your schema type definitions, so that you can quickly start using this feature. We will also be working on improving API docs for this.</p>\n<p>We strongly believe that these new APIs are the foundation of an evolutionary leap of the Gatsby GraphQL API. These changes make the GraphQL API more stable, more robust, and more easily customizable. They will enable further customization and use cases, like <a href=\"/gatsby-bloga-2/blog/2018-11-11-introducing-gatsby-themes/\">theming</a> and more still that we haven‚Äôt even envisioned yet. We truly can‚Äôt wait to see the great things you build and how you use these new APIs and improvements powered by Gatsby and its improved GraphQL layer. We got some very enthusiastic feedback about this feature and we are happy to have it released.</p>\n<p><a href=\"https://twitter.com/datocms/status/1103896814351048704\">https://twitter.com/datocms/status/1103896814351048704</a></p>\n<h3>Additional Resources</h3>\n<ul>\n<li><a href=\"https://github.com/gatsbyjs/gatsby/issues/12272\">Meta issue</a> for bug reports</li>\n<li><a href=\"/gatsby-bloga-2/docs/actions/#createTypes\">API docs for createTypes</a></li>\n<li><a href=\"/gatsby-bloga-2/docs/node-apis/#createResolvers\">API docs for createResolvers</a></li>\n<li><a href=\"/gatsby-bloga-2/docs/node-model\">API docs for node model</a></li>\n<li><a href=\"https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions\">Using type definitions example</a></li>\n</ul>","frontmatter":{"title":"New Schema Customization API - Available in Gatsby 2.2.0","date":"March 19, 2019","description":null}}},"pageContext":{"slug":"/docs/blog/2019-03-18-releasing-new-schema-customization/","previous":{"fields":{"slug":"/docs/blog/2019-03-15-design-code-blog-post/"},"frontmatter":{"title":"Gatsby Fuels Content and Sales in Design+Code Rebuild"}},"next":{"fields":{"slug":"/docs/blog/2019-03-21-migrating-from-wordpress-to-gatsby/"},"frontmatter":{"title":"Migrating From WordPress to Gatsby"}}}}}