{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2019-03-11-gatsby-themes-roadmap/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"1c04c0e6-3a77-5eda-be87-500732b5538f","excerpt":"Gatsby themes have come a long way in the last few months. We’ve iteratively\nshipped functionality that has enabled people to ship sites quickly on short…","html":"<p>Gatsby themes have come a long way in the last few months. We’ve iteratively\nshipped functionality that has enabled people to ship sites quickly on short\ndeadline with an absolute minimum (1) of breaking changes. In this post we’ll\ncover what we’ve shipped to date, where we are today, and what the roadmap looks\nlike for where we’re going:</p>\n<ol>\n<li>Theme Composition</li>\n<li>Component Shadowing 2a. Improving Docs</li>\n<li>Simplifying the Data Model</li>\n<li>?</li>\n</ol>\n<h2>Theme Composition</h2>\n<p>The core theme composition algorithm was the first set of functionality we\nworked on. This piece of the code at its core can be thought of as\n<code class=\"language-text\">Object.assign</code> for <code class=\"language-text\">gatsby-config.js</code>. Given an array of themes, each\n<code class=\"language-text\">gatsby-config</code> is merged into the next. For example, if we have <code class=\"language-text\">[themeA, themeB]</code>, the resulting config is <code class=\"language-text\">{ ...themeA, ...themeB }</code>.</p>\n<p>There are also some special considerations for how we merge specific fields of\nthe <code class=\"language-text\">gatsby-config</code>. <code class=\"language-text\">siteMetadata</code> is merged using <a href=\"https://lodash.com/docs/#merge\">Lodash’s deep\nmerge</a>, allowing users to override fields like\nthe title of a blog, or the tokens in a design system that are shared across\nmultiple themes. <code class=\"language-text\">plugins</code> are added together so that each theme’s plugins are\nrepresented in the result (<code class=\"language-text\">[...themeA.plugins, ...themeB.plugins]</code>). To allow\nthe usage of <code class=\"language-text\">gatsby-*</code> lifecycle APIs in themes, we also add each theme as a\nplugin itself, resulting in <code class=\"language-text\">[...themeA.plugins, themeA, ...themeB.plugins, themeB]</code>. This results in the theme being able to add functionality on top of\nany plugin it includes.</p>\n<p>For more on this, read <a href=\"/gatsby-bloga-2/blog/2018-11-11-introducing-gatsby-themes/\">Introducing Gatsby\nThemes</a>.</p>\n<p>We introduced one major change to composition after the initial release to\nsupport child themes. A child theme is a theme that also uses the\n<code class=\"language-text\">plugins</code> <code class=\"language-text\">gatsby-config</code> key – a change that brought the full power\nof <code class=\"language-text\">gatsby-config</code> to theming.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=\"achild theme's gatsby-config.js\"\"><pre class=\"language-js:title=\"achild theme's gatsby-config.js\"\"><code class=\"language-js:title=\"achild theme's gatsby-config.js\"\">module.exports = {\n  plugins: [`gatsby-theme-blog-core`],\n}</code></pre></div>\n<p>Child themes under the hood are implemented by extending the original\ncomposition algorithm to be recursive. This means you can have as many or as few\nthemes as you want, and that implementing it was <em>not</em> a breaking change for\nanyone. One really interesting facet of child themes in Gatsby compared to\nanywhere else is the ability to have a tree of themes. In the following example\neach theme points to its parents. (So <code class=\"language-text\">gatsby-theme-supertheme</code> references\n<code class=\"language-text\">gatsby-theme-a</code> and <code class=\"language-text\">gatsby-theme-b</code> in its <code class=\"language-text\">gatsby-config</code>). We have 7 total\nthemes and the user only has to know about and install\n<code class=\"language-text\">gatsby-theme-supertheme</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">gatsby-theme-supertheme\n├── gatsby-theme-a\n│   ├── gatsby-theme-a1\n│   ├── gatsby-theme-a2\n│   └── gatsby-theme-a3\n└── gatsby-theme-b\n    └── gatsby-theme-b1</code></pre></div>\n<p>This flexibility allows us to come up with new patterns for abstracting\nfunctionality into themes. Since we’re still in the early days we don’t know\nwhat best practices will end up being and if you’re just getting started its a\ngood idea to build out a single theme before attempting to build a set of themes\nthat work together.</p>\n<h2>Component Shadowing</h2>\n<p>The next problem we approached can be described as “How do I change the\nnavigation component in a theme?“.</p>\n<p>Composition is useful but if you can’t override the way data displays by\nchanging the rendering, then we are left with fairly inflexible systems. Given\nthat page templates and other functionality can be changed using Gatsby\nlifecycles such as <code class=\"language-text\">onCreatePage</code>, that left us with how to allow arbitrary\nchanges to how a specific sub-section of the page renders. Component shadowing\ncame next as the solution to this problem.</p>\n<p>Component shadowing is based on the idea that Gatsby sites are built up out of\nReact components. At any given point in the tree that is your site, you have a\nReact component (or set of components) responsible for handling the rendering of\nsome props. This could be low level like a <code class=\"language-text\">Text</code> or <code class=\"language-text\">Heading</code> component, higher\nlevel compositions <a href=\"http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/\">like <code class=\"language-text\">Media</code>\nobjects</a>,\nthe <code class=\"language-text\">Navigation</code> component, or even a full page layout. Component shadowing\nallows you to find the place a component is defined in a theme, such as\n<code class=\"language-text\">gatsby-theme-blog/src/author.js</code>, and replace it by creating a file in your\nsite at <code class=\"language-text\">my-site/src/gatsby-theme-blog/author.js</code>.</p>\n<p>In fact, any file that is processed by webpack can be shadowed.</p>\n<p>To learn more about child themes and component shadowing, <a href=\"/gatsby-bloga-2/blog/2019-01-29-themes-update-child-theming-and-component-shadowing/\">read this themes\nupdate blog\npost</a>.</p>\n<h2>Improving Documentation</h2>\n<p>After composition and shadowing were released, we focused a bit on fixing any\nbugs that popped up and expanding usage to a wider audience. Some companies have\nalready shipped <a href=\"https://twitter.com/peggyrayzis/status/1095407450424049664\">child\nthemes</a> and\n<a href=\"https://twitter.com/trevorblades/status/1095118425473445888\">component\nshadowing</a> to\nproduction with impressive results: lowering development time and enabling\ndevelopment that might not have been able to ship within the necessary timeframe\non other platforms.</p>\n<p>We’ve also written and are updating a set of documentation that will be released\non gatsbyjs.org for anyone that is using or looking to start using themes.</p>\n<h2>Simplifying the Data Model</h2>\n<p>We shipped composition, child themes, and component shadowing and we’re not\nstopping there. Next up on our plate is something you may have seen us tweeting\nabout: dealing with data. The GraphQL model Gatsby uses is fantastic for doing\nany kind of custom work, which is great for theme creators, but it means that as\na theme user you’re often locked into using <code class=\"language-text\">MarkdownRemark</code> when you’d rather\nbe using <code class=\"language-text\">Mdx</code>.</p>\n<p>Currently most of the folks using themes are experienced Gatsby users. As we\nstart to have more and more themes publicly available, we’ll have more and more\nnewer Gatsby users installing and using them. Offering a simplified data model\nthat can switch between backing content types means that instead of a theme\ntying itself to <code class=\"language-text\">MarkdownRemark</code>, it can tie itself to a generic data type like\n<code class=\"language-text\">BlogPost</code> that can be implemented by <code class=\"language-text\">MarkdownRemark</code> under the hood. We could\nuse these generic data types as an (optional, extensible) target for theme\ncreators. More creators building around community vetted core types means that\nmore themes will be able to be swapped in place of one another and more themes\nwill be compatible composing together. Imagine a blog theme that extends the\ncore community <code class=\"language-text\">BlogPost</code> type with multi-author support. It would be\nimmediately compatible with any theme that used the <code class=\"language-text\">BlogPost</code> type.</p>\n<p>If you’re following closely you may have already seen <a href=\"/gatsby-bloga-2/blog/2019-03-04-new-schema-customization/\">a blog post by Mikhail\nNovikov</a> on\nthe new schema customization APIs: <code class=\"language-text\">createTypes</code> and <code class=\"language-text\">createResolvers</code>. These\nare the primitives we are using to build data abstractions to use with themes.\nWe’re still experimenting and doing research here so I won’t show any code\ntoday. If you want to participate in the development of the data abstraction, I\nhighly encourage you to install <code class=\"language-text\">gatsby@schema-customization</code> and play around.</p>\n<h2>The Future</h2>\n<p>There are a number of directions we can go from here to give a better user\nexperience to developing and using themes for experienced Gatsby contributors\nand new users alike. Building out potential UX improvements to shadowing for\nmore complex multi-theme authoring use cases, defining patterns for sharing\ndesign tokens and data abstractions across themes, and building a cohesive set\nof themeable components for a set of official Gatsby themes are all directions\nyou may see us together with the community work on in the future.</p>\n<p>That’s a peek inside where themes is going. Get started building your own themes\ntoday and let us know what you build! Be sure to check back in on the Gatsby\nblog this month as we have theming related posts from\n<a href=\"https://twitter.com/jlengstorf\">@jlengstorf</a>,\n<a href=\"https://twitter.com/4lpine\">@4lpine</a>, and <a href=\"https://twitter.com/jxnblk\">@jxnblk</a>\ncoming shortly.</p>","frontmatter":{"title":"Gatsby Themes Roadmap","date":"March 11, 2019","description":null}}},"pageContext":{"slug":"/docs/blog/2019-03-11-gatsby-themes-roadmap/","previous":{"fields":{"slug":"/docs/blog/2019-03-07-sell-gatsby-to-clients/"},"frontmatter":{"title":"How to Talk about Gatsby to Clients and Your Team"}},"next":{"fields":{"slug":"/docs/blog/2019-03-11-dot-org-prototypes/"},"frontmatter":{"title":"How we tested prototypes for the new gatsbyjs.org homepage"}}}}}