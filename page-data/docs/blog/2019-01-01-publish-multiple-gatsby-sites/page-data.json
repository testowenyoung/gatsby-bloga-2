{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2019-01-01-publish-multiple-gatsby-sites/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"a4bb144c-b6a2-5f74-95d7-88ddc08ce871","excerpt":"Learn how to create a balanced lasagna instead of a tangled mess of spaghetti. Foreword This tutorial will take about two hours to complete. If you’re…","html":"<h2>Learn how to create a balanced lasagna instead of a tangled mess of spaghetti.</h2>\n<h3>Foreword</h3>\n<p>This tutorial will take about two hours to complete. If you’re unfamiliar with Lerna, Travis or Vercel, you may fall into a few traps, but it’s all part of the learning process! I’ve included a troubleshooting section at the end of the article for common problems, so refer to it at any time.</p>\n<h3>Introduction</h3>\n<p>If you work alone or in a small team, you’re likely to have started working on small programs that slowly grow complex and convoluted. Shit happens and you’ll soon find that your perfectly balanced lasagna evolves into a heaped bowlful of spaghetti.</p>\n<p>The same goes for those who have worked as part of a large company/team. Branding guidelines come in the form of CSS style-guides or reusable components. Separating the discrete packages from what’s shared becomes a hassle if everything’s stored together. You may even have to deal with several similar projects thrown about in different repos, which can be a headache to keep track of. These are some of the problems monorepos solve.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/6533e/monorepo-diagram.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 53.37837837837838%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIBBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe4qTQf/xAAWEAEBAQAAAAAAAAAAAAAAAAAQATH/2gAIAQEAAQUCJj//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAVEAEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAQAGPwJr/8QAHBAAAgICAwAAAAAAAAAAAAAAAAERMSFRYYHR/9oACAEBAAE/IctpXRnmtEreEkJiUKEf/9oADAMBAAIAAwAAABCQD//EABURAQEAAAAAAAAAAAAAAAAAAAAB/9oACAEDAQE/EFf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEBAQABBQAAAAAAAAAAAAABEQAhUWGRseH/2gAIAQEAAT8QJiw8LJ9zCx8nnJBq9z01dcsVOUmIggb/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Monorepo Diagram\"\n        title=\"Monorepo Diagram\"\n        src=\"/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/1c72d/monorepo-diagram.jpg\"\n        srcset=\"/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/a80bd/monorepo-diagram.jpg 148w,\n/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/1c91a/monorepo-diagram.jpg 295w,\n/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/1c72d/monorepo-diagram.jpg 590w,\n/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/a8a14/monorepo-diagram.jpg 885w,\n/gatsby-bloga-2/static/72822e30046f7c951f06907d80b27009/6533e/monorepo-diagram.jpg 1160w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>A monorepo is an architectural design pattern that allows us to maintain several packages within a single repo. This reduces the complexity when dealing with packages that share in-house and third-party dependencies.</p>\n<p>Think of monorepos like a well-organized supermarket. Each aisle contains a particular kind of food, making it easy to navigate and find the item of food you want. Supermarkets also contain a variety of different foods so you don’t need to go to a series of specific shops to find your gluten-free, dairy-free banoffee pie (which is very much a <a href=\"https://glutenfreecuppatea.co.uk/2016/02/14/recipe-healthy-banoffee-pie-gluten-free-vegan-refined-sugar-free-dairy-free/\">thing</a>).</p>\n<p>With monorepos the code is split into specific packages (aisles). Meaning you can easily navigate the project to find the component or module you want to work on. It also means not needing to maintain separate repos when making changes that affect multiple parts of your stack (the single shop).</p>\n<p>Everything is accessible from a single place, while still being organized enough to navigate painlessly.\nEnough with the theory, let’s move on to the tutorial, which is split into 2 sections: development and deployment.</p>\n<p><em>Development</em> — We’ll configure an existing application, built with <a href=\"/gatsby-bloga-2/\">Gatsby</a>, into a monorepo. I won’t delve too much into its implementation details because it’s beyond the scope of this article. We’ll attend the lavish party that the great Gatsby throws for us and we won’t ask why or how they did it.</p>\n<p>Another tool we’ll use is <a href=\"https://github.com/lerna/lerna\">Lerna</a>, which will manage the dependencies of our project. Lerna will also allow us to link packages together which we’ll use to share components.</p>\n<p><em>Deployment</em> — After we’ve converted our app into a monorepo we’ll hook our GitHub account to Travis-CI and create a CI pipeline. The CI pipeline will test, build and deploy our application.</p>\n<p>There are a couple of caveats to address prior to beginning:</p>\n<p>Due to the scale of our demo site, you may feel that monorepos aren’t practical. You’ll be right in thinking that because a monorepo in this instance isn’t practical. There’ll be elements of duplication and rewriting that will seem counter productive. It’ll also seem like we’re over-engineering a simple site. The real learning comes from understanding how the pieces fit together on a small scale. You’ll be able to easily integrate monorepos at production level with your understanding of the fundamental concepts and underlying technologies.</p>\n<p>This tutorial deals with loads of small changes which make for plenty of opportunities for things to go wrong. I’ve tried making myself as clear as possible to prevent this but if you do come across issues then leave a descriptive comment. I’ll do my best to respond, edit and improve this article. You can also find the <a href=\"https://github.com/andrico1234/lerna-monorepo-finisher\">finished repo here</a>. There’s no shame in copying my code if you’re stuck.</p>\n<p>I’m also assuming fundamental web dev knowledge including experience with React, Git and the command line.</p>\n<h3>Part One</h3>\n<p>Let’s begin! Navigate to an empty folder in the terminal and clone the repo by running the following command</p>\n<p><code class=\"language-text\">git clone git@github.com:andrico1234/lerna-monorepo-starter.git</code></p>\n<p>and navigate into the <code class=\"language-text\">lerna-monorepo-starter</code> directory.</p>\n<p>Go to your GitHub account and create a new repo, this’ll be the repo that you push the site to so that Travis can run the pipeline. For those who need a refresher on how to <a href=\"https://help.github.com/articles/creating-a-new-repository/\">create a new repo</a>. You may have to run <code class=\"language-text\">git remote remove origin</code> so you can point the code to your newly created repo.</p>\n<p>Run the code that GitHub outputs when creating a new repo:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> remote <span class=\"token function\">add</span> origin git@github.com:<span class=\"token operator\">&lt;</span>account-name<span class=\"token operator\">></span>/lerna-monorepo-starter.git\n<span class=\"token function\">git</span> push -u origin master</code></pre></div>\n<p>Commit and push regularly for best results.</p>\n<p>Navigate inside of the <code class=\"language-text\">lerna-monorepo-starter</code> directory and install the packages by running <code class=\"language-text\">yarn</code>. Once your packages have installed, run <code class=\"language-text\">yarn develop</code> to run the application on <code class=\"language-text\">http://localhost:8000</code>.</p>\n<p>Open Chrome, and navigate to <code class=\"language-text\">http://localhost:8000</code>. You’ll find a simple application with a mock blog and a mock shop. Imagine this is a fleshed out application, we can make the assumption that the underlying logic behind the blog and the shop are different and that there are similarities with the styling and components.</p>\n<p>Go back to your IDE and you’ll see that we’re not pulling data from an external source. The data is being served locally via a couple of JSON files in the <code class=\"language-text\">data</code> directory. When we run the <code class=\"language-text\">develop</code> command Gatsby pulls the data from these JSON files and creates pages for them. You can take a look at how this being done by peeking inside of the <code class=\"language-text\">gatsby-node.js</code> file. This is because Gatsby builds the code and outputs a static site.</p>\n<p>So imagine our application is starting to grow, the shop and the blog start intertwining with each other. You may not notice the lack of separation until its too late and your code is tangled tighter than the ivy across the side of your grandma’s cottage.</p>\n<p>Let’s start splitting up our application. I’ll only be touching the surface of what Lerna is capable of, so I’d recommend checking out their repo to learn more. Install Lerna with <code class=\"language-text\">yarn global add lerna</code>. We need to create a file in the root directory called <code class=\"language-text\">lerna.json</code>. Add in the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"lerna\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"2.11.0\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"packages\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"packages/*\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"npmClient\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"yarn\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"useWorkspaces\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"1.0.0\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The above specifies the version of Lerna we’re using. We also let Lerna know where to find our packages, in this case the packages will be contained within a directory inside of <code class=\"language-text\">packages</code>. We specify that we’re using Yarn, the current version of our application and that we’re using Yarn Workspaces enables Lerna’s package hoisting. To enable Yarn workspaces, add the following to your <code class=\"language-text\">package.json</code> file.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  ...rest of file<span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"private\"</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"workspaces\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token string\">\"packages/*\"</span>\n  <span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Once that’s been completed create a new <code class=\"language-text\">packages</code> directory in the root of the project. Create three additional directories inside of it so the structure looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">packages\n | blog\n | shared-ui\n | shop</code></pre></div>\n<p>The next step is to move the contents from our current application into their respective folders. All the files in our <code class=\"language-text\">components</code> folder will be moved to our <code class=\"language-text\">shared-ui</code> directory since we’d like to be able to use them anywhere throughout our codebase.</p>\n<p>For now we’ll move everything over to <code class=\"language-text\">shared-ui</code> components and import them using a relative url.</p>\n<p>Inside of the <code class=\"language-text\">packages/shared-ui</code> directory, I’ve created a file called <code class=\"language-text\">index.js</code> which will be our entry point for importing components. This is the directory that we’re going to be moving our components folder into. Open up your terminal and navigate to the top level of your project directory and run</p>\n<p><code class=\"language-text\">mv src/components/ packages/shared-ui/components/</code></p>\n<p>This will move the components into their brand new home. Go ahead and do the same for the <code class=\"language-text\">theme</code> directory too. You’re going to need to fix the now broken import statements for each component that uses the theme object.</p>\n<p>The Layout component behaves as the entry point of each Gatsby application, which means that each package will need one.</p>\n<p>We’ll avoid code duplication by abstracting the parts of the layout that won’t need to change based on the page, like the use of the Header component. We’ll keep each package’s individual logic, like the <code class=\"language-text\">graphql</code> query.</p>\n<p>In <code class=\"language-text\">packages/shared-ui</code>, create a new directory called <code class=\"language-text\">layouts/PrimaryLayouts</code>. Create an <code class=\"language-text\">index.js</code> file and move over the contents of the <code class=\"language-text\">src/layouts/index.js</code> file here. Once that’s done get rid of the <code class=\"language-text\">graphql</code> query. Move over the CSS file so the imports don’t break.</p>\n<p>Back in the <code class=\"language-text\">src/layouts</code> file we can get rid of everything and replace it with this:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx:title=layout/index.js\"><pre class=\"language-jsx:title=layout/index.js\"><code class=\"language-jsx:title=layout/index.js\">import React from &quot;react&quot;\nimport PropTypes from &quot;prop-types&quot;\n\nimport { PrimaryLayout } from &quot;../../packages/shared-ui&quot;\n\nconst Layout = ({ children, data }) =&gt; (\n  &lt;PrimaryLayout children={children} data={data} /&gt;\n)\n\nLayout.propTypes = {\n  children: PropTypes.func,\n}\n\nexport default Layout\n\nexport const query = graphql`\n  query SiteTitleQuery {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n  }\n`</code></pre></div>\n<p>Once that’s done update the export statements in <code class=\"language-text\">the shared-ui/index.js</code> file to look like the following.</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx:title=index.js\"><pre class=\"language-jsx:title=index.js\"><code class=\"language-jsx:title=index.js\">export { default as theme } from &quot;./theme&quot;\n\nexport { default as Button } from &quot;./components/Button&quot;\nexport { default as Header } from &quot;./components/Header&quot;\nexport { ItemCard, ItemCardWrapper } from &quot;./components/ItemCard&quot;\n\nexport { default as PrimaryLayout } from &quot;./layouts/PrimaryLayouts&quot;</code></pre></div>\n<p>Your packages folder hierarchy should look like this now</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">packages\n  | blog\n  | shared-ui\n    | index.js\n    | components\n      | Button\n        | index.js\n      | Header\n        | index.js\n      | ItemCard\n        | index.js\n    | theme\n      | index.js\n    | layouts\n      | PrimaryLayout\n        | index.js\n        | index.css\n  | shop</code></pre></div>\n<p>It’s likely that your project won’t run because the import statements for your shared components will have broken. The way the project’s set up means that we can do a find-and-replace to find <code class=\"language-text\">../components/{specific-component}</code> and replace it with <code class=\"language-text\">../../packages/shared-ui</code>. The site will still be broken because we need to wrap the import name with curly braces, so the import statement looks like this:</p>\n<p><code class=\"language-text\">import { Header } from ‘../../packages/shared-ui’</code></p>\n<p>Just make sure the Header import for your <code class=\"language-text\">PrimaryLayout/index.js</code> is as follows <code class=\"language-text\">import { Header } from &#39;../../&#39;</code>. Once you’ve replaced all the outdated import statements with new ones, try running your application again. We should expect to see no errors in the console. Now’s a good time to commit and push the code.</p>\n<p>Now we’ve got this working, we want to take it one step further and make the shared-ui behave in the same way a public package does. Create a <code class=\"language-text\">package.json</code> file inside of the <code class=\"language-text\">shared-ui</code> package and add the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=package.json\"><pre class=\"language-json:title=package.json\"><code class=\"language-json:title=package.json\">{\n  &quot;name&quot;: &quot;@lerna-monorepo/shared-ui&quot;,\n  &quot;description&quot;: &quot;Lerna monorepo starter&quot;,\n  &quot;version&quot;: &quot;1.0.2&quot;,\n  &quot;dependencies&quot;: {\n    &quot;gatsby&quot;: &quot;^1.9.247&quot;,\n    &quot;gatsby-link&quot;: &quot;^1.6.40&quot;,\n    &quot;gatsby-plugin-react-helmet&quot;: &quot;^2.0.10&quot;,\n    &quot;gatsby-plugin-react-next&quot;: &quot;^1.0.11&quot;,\n    &quot;react&quot;: &quot;16.4.2&quot;,\n    &quot;react-helmet&quot;: &quot;^5.2.0&quot;,\n    &quot;styled-components&quot;: &quot;^3.3.3&quot;\n  },\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https://github.com/gatsbyjs/gatsby-starter-default&quot;\n  }\n}</code></pre></div>\n<p>This will add the necessary dependencies for our <code class=\"language-text\">shared-ui</code> package.</p>\n<p>Now we’re going to want to split up our original application into two separate packages; blog and shop. We’re going to need to mimic the current hierarchy to ensure that Gatsby keeps working. Each package will have a:</p>\n<ul>\n<li>data directory</li>\n<li>src directory with layouts and pages</li>\n<li>gatsby-config.js</li>\n<li>gatsby-node.js</li>\n<li>package.json file</li>\n</ul>\n<p>Go ahead and create blank folders/files for each item in the list above inside of each package. We’ll go through each item one by one for the blog package, then I’ll leave you to implement this for the shop package. You can refer to the finished repo at anytime if you’re stuck.</p>\n<p>Data directory — Move the <code class=\"language-text\">blog.json</code> file in the top level <code class=\"language-text\">data</code> directory. Go to your console, move to the repo’s top level directory and execute the following command <code class=\"language-text\">mv data/blog.json packages/blog/data/blog.json</code>. This moves our mock blog data into its rightful home.</p>\n<p>Src directory with layouts and pages — In <code class=\"language-text\">packages/blog/src/layouts</code>, create an <code class=\"language-text\">index.js</code> file. Copy and paste the contents of the top level <code class=\"language-text\">src/layouts/index.js</code> file. Your IDE might start shouting at you because <code class=\"language-text\">../../packages/shared-ui</code> is no longer a valid import location. We finally get to use the brand spanking new <code class=\"language-text\">shared-ui</code> package we created earlier on. Change the old import location to <code class=\"language-text\">@lerna-monorepo/shared-ui</code>. Create two new files inside the <code class=\"language-text\">packages/blog/src/pages/</code> directory with the file name of <code class=\"language-text\">index.js</code> and <code class=\"language-text\">blogItem.js</code>. In the <code class=\"language-text\">index.js</code> file copy the contents of the <code class=\"language-text\">blog.js</code> file under the <code class=\"language-text\">src/pages/</code> directory. Update the import for the <code class=\"language-text\">shared-ui</code> package like we did for the index file. Do the same for the <code class=\"language-text\">blogItem.js</code> file. You’ll need to change the ‘back to blog’ to attribute in this file to ‘/’.</p>\n<p>gatsby-config.js — Again, copy the contents of the top level <code class=\"language-text\">gatsby-config.js</code> file with the one in the blog package.</p>\n<p>gatsby-node.js — We’ll only know whether everything works or if our site craps itself once we move this file and add the <code class=\"language-text\">package.json</code>. We want to copy over only the logic relating to the processing of the blog data. Copy and paste everything into the empty <code class=\"language-text\">gatsby-node.js</code> file. Remove all the lines between and including 6–33, as well as the bottom most right curly bracket, and the right parenthesis on the second to last line.</p>\n<p>package.json- Add the following to the <code class=\"language-text\">package.json</code> file:</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=package.json\"><pre class=\"language-json:title=package.json\"><code class=\"language-json:title=package.json\">{\n  &quot;name&quot;: &quot;@lerna-monorepo/blog&quot;,\n  &quot;description&quot;: &quot;Lerna monorepo starter&quot;,\n  &quot;version&quot;: &quot;1.0.2&quot;,\n  &quot;dependencies&quot;: {\n    &quot;@lerna-monorepo/shared-ui&quot;: &quot;^1.0.1&quot;,\n    &quot;gatsby&quot;: &quot;^1.9.247&quot;,\n    &quot;gatsby-link&quot;: &quot;^1.6.40&quot;,\n    &quot;gatsby-plugin-react-helmet&quot;: &quot;^2.0.10&quot;,\n    &quot;gatsby-plugin-react-next&quot;: &quot;^1.0.11&quot;,\n    &quot;gatsby-react-router-scroll&quot;: &quot;^1.0.18&quot;,\n    &quot;gatsby-source-filesystem&quot;: &quot;^1.5.39&quot;,\n    &quot;gatsby-transformer-json&quot;: &quot;^1.0.20&quot;,\n    &quot;react&quot;: &quot;^16.4.2&quot;,\n    &quot;react-helmet&quot;: &quot;^5.2.0&quot;,\n    &quot;react-router-dom&quot;: &quot;4.3.1&quot;,\n    &quot;serve&quot;: &quot;^10.0.0&quot;,\n    &quot;styled-components&quot;: &quot;^3.3.3&quot;\n  },\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;serve public/&quot;,\n    &quot;build&quot;: &quot;gatsby build&quot;,\n    &quot;develop&quot;: &quot;gatsby develop&quot;\n  }\n}</code></pre></div>\n<p>As well as the dependencies we defined in our top level <code class=\"language-text\">package.json</code> file, I’ve added a couple more that we’ll use later. You won’t need to worry about what they do for now.</p>\n<p>Note: In your top level <code class=\"language-text\">package.json</code> change the version of React to <code class=\"language-text\">16.0.0</code>. I explain why in the troubleshooting section at the bottom of the article.</p>\n<p>You should notice that we’ve added <code class=\"language-text\">&quot;@lerna-monorepo/shared-ui&quot;: &quot;^1.0.0&quot;</code> to the list dependencies. This will treat our <code class=\"language-text\">shared-ui</code> package as a standard node module. Run <code class=\"language-text\">lerna clean</code> and <code class=\"language-text\">lerna bootstrap</code> to update your packages.</p>\n<p>Once you’ve done this, try navigating to the <code class=\"language-text\">packages/blog</code> directory and running <code class=\"language-text\">yarn develop</code>. Hopefully everything compiles and you should be able to access the homepage. Because the shop hasn’t been implemented, trying to navigate to that part of the application will result in failure. Go ahead and do the same for the shop package.</p>\n<p>Here’s the <code class=\"language-text\">package.json</code> file for the shop package:</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=package.json\"><pre class=\"language-json:title=package.json\"><code class=\"language-json:title=package.json\">{\n  &quot;name&quot;: &quot;@lerna-monorepo/shop&quot;,\n  &quot;description&quot;: &quot;Lerna monorepo finisher&quot;,\n  &quot;version&quot;: &quot;1.0.2&quot;,\n  &quot;dependencies&quot;: {\n    &quot;@lerna-monorepo/shared-ui&quot;: &quot;^1.0.1&quot;,\n    &quot;gatsby&quot;: &quot;^1.9.247&quot;,\n    &quot;gatsby-link&quot;: &quot;^1.6.40&quot;,\n    &quot;gatsby-plugin-react-helmet&quot;: &quot;^2.0.10&quot;,\n    &quot;gatsby-plugin-react-next&quot;: &quot;^1.0.11&quot;,\n    &quot;gatsby-source-filesystem&quot;: &quot;^1.5.39&quot;,\n    &quot;gatsby-transformer-json&quot;: &quot;^1.0.20&quot;,\n    &quot;gatsby-react-router-scroll&quot;: &quot;^1.0.18&quot;,\n    &quot;react&quot;: &quot;^16.4.2&quot;,\n    &quot;react-helmet&quot;: &quot;^5.2.0&quot;,\n    &quot;react-router-dom&quot;: &quot;4.3.1&quot;,\n    &quot;serve&quot;: &quot;^10.0.0&quot;,\n    &quot;styled-components&quot;: &quot;^3.3.3&quot;\n  },\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;serve public&quot;,\n    &quot;build&quot;: &quot;gatsby build&quot;,\n    &quot;develop&quot;: &quot;gatsby develop -p 8001&quot;\n  }\n}</code></pre></div>\n<p>I’ve made a slight change in this file, so that running both packages won’t cause a port clash. If you can navigate to both packages and run <code class=\"language-text\">yarn develop</code> without the script throwing an error, then commit and push your changes.</p>\n<p>There are two major issues we need to address:</p>\n<p>Having to run each package manually is a pain.\nOur website doesn’t recognise that we’re linking between two different packages.\nWe’ll resolve the first issue by creating a top level script that runs both the blog and shop in parallel. The second issue we’ll solve by adding <code class=\"language-text\">.env</code> variables that will hold the addresses for the blog/shop urls. The variables will be different for the production environment and will hold the live urls.</p>\n<p>Add the following to the scripts block of your top level <code class=\"language-text\">package.json</code> file.</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=package.json\"><pre class=\"language-json:title=package.json\"><code class=\"language-json:title=package.json\">&quot;scripts&quot;: {\n  &quot;run:blog&quot;: &quot;cd packages/blog &amp;&amp; yarn develop&quot;,\n  &quot;run:shop&quot;: &quot;cd packages/shop &amp;&amp; yarn develop&quot;,\n  &quot;run:all&quot;: &quot;npm-run-all --parallel run:blog run:shop&quot;\n}</code></pre></div>\n<p>The first two run each package’s Gatsby server individually, while the latter uses <code class=\"language-text\">npm-run-all</code> to run the scripts in parallel. Install <code class=\"language-text\">npm-run-all</code> using <code class=\"language-text\">lerna add npm-run-all</code> in the top level of your project.</p>\n<p>Note: <code class=\"language-text\">npm-run-all</code> runs both Gatsby instances in the same terminal window. So logging for both the shop and blog outputs to the same window. You’ll need to press cmd+d twice to kill the Gatsby process.</p>\n<p>To navigate between both our Gatsby sites on development we’re going to need to add environment variables so to use with the <code class=\"language-text\">Link</code> components. We’ll add the <code class=\"language-text\">dotenv</code> package so Gatsby knows which variables to load for a given environment.</p>\n<p><code class=\"language-text\">lerna add dotenv --scope=*{@lerna-monorepo/shop,@lerna-monorepo/blog}*</code></p>\n<p>This adds the <code class=\"language-text\">dotenv</code> module to only the blog and shop packages, this way we don’t add unnecessary dependencies to our <code class=\"language-text\">shared-ui</code> package.</p>\n<p>Create a new file in your shop package called <code class=\"language-text\">.env.development</code> and <code class=\"language-text\">.env.production</code>. Inside the former, add the following line:</p>\n<p><code class=\"language-text\">BLOG_URL=http://localhost:8000</code></p>\n<p>Leave the production file alone for now and repeat for blog package, just change the name of the variable to <code class=\"language-text\">SHOP_URL</code> and the port to <code class=\"language-text\">8001</code>.</p>\n<p>Now add the following code to the top of your <code class=\"language-text\">gatsby-config.js</code> file in your shop package.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-config.js\"><pre class=\"language-js:title=gatsby-config.js\"><code class=\"language-js:title=gatsby-config.js\">const activeEnv = process.env.ACTIVE_ENV | &quot;development&quot;\n\nrequire(&quot;dotenv&quot;).config({\n  path: `.env.${activeEnv}`,\n})</code></pre></div>\n<p>Add this code to the blog’s <code class=\"language-text\">gatsby-config.js</code> file too. This code snippet will give you access to these variables inside of our components. We can provide different sets of variables depending on the current environment. When we later run gatsby build to create our static site, it will use the production variables.</p>\n<p>Once we’ve add that, we’re going to need to find all instances where we navigate from the blog site to the shop site and vice versa, you’ll need to replace the current Links to:</p>\n<p><code class=\"language-text\">&lt;a href={process.env.SHOP_URL}&gt;Back to Shop&lt;/a&gt;</code></p>\n<p>Protip: they’re in <code class=\"language-text\">shop/src/pages/index.js</code>, and <code class=\"language-text\">blog/src/pages/index.js</code>.</p>\n<p>This will allow us to transition between our two sites. Do the same for the shop package and you’ll be able to use the site as normal. If <code class=\"language-text\">yarn run:all</code> still works and you can run <code class=\"language-text\">yarn build</code> for each package then commit and push the changes. In each package run <code class=\"language-text\">yarn serve</code> go to the correct port to double-check that everything displays correctly.</p>\n<p>Congratulations, the site now behaves in exactly the same way as when we started. This might make it seem like monorepos have little use, but you’ll find that using a monorepo is a way of keeping packages independent from each other while easily reusing assets.</p>\n<p>You can stop the tutorial now and you’ll have a working knowledge of when, how and why to use monorepos, but the latter half of this tutorial will show us how we can take things a step further. We’ll get a CI pipeline set up for our application and deploy it on success.</p>\n<h3>Part Two</h3>\n<p>Let’s take a second to reflect on where we are right now. We’ve managed to start with a single application with two discrete sections and split them apart in a monorepo. This allows us to <em>separate the concerns</em> and share reusable components.</p>\n<p>There are two parts to this section, our Continuous Integration (CI) pipeline and the site’s deployment. Our CI pipeline will be used to automate a series of checks to ensure our tests pass and our build compiles. If either of these, or any part of the pipeline, fails then our site won’t deploy. The second part is how we deal with a successful build, and that’s deployment! If everything passes, our site will deploy using Vercel, where it will be hosted for the world to see on the interwebs.</p>\n<p>To use Travis we’ll first need to create an account and add the GitHub repo we’ve been pushing to. And like with every other tool we’ve used, the best way to get started with Travis is by reading <a href=\"https://docs.travis-ci.com/user/getting-started/\">Travis’ getting started page</a>. The getting started page also runs through adding your GitHub repo which can be done via the main page. Click the ‘+’ and on your profile page click ‘Manage repositories in GitHub’. Choose the repo that you’ve been using and you should be set up.</p>\n<p>Once you’ve done this we’ll create our <code class=\"language-text\">.travis.yml</code> which outlines the steps our CI pipeline will take when preparing for deployment. Travis won’t recognise any application that doesn’t have a <code class=\"language-text\">.travis.yml</code>, so we’ll create a basic one. Once we push code that contains a <code class=\"language-text\">.travis.yml</code> file, the CI pipeline will start running on every subsequent push.</p>\n<p>In the root of your project create a file named <code class=\"language-text\">.travis.yml</code>. And please, please, pleaaase make sure you’ve spelt the file name correctly. I was racking my head for the best part of an hour wondering why my build wasn’t running, only to discover I had left out the leading period in the <code class=\"language-text\">.travis.yml</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml:title=.travis.yml\"><pre class=\"language-yaml:title=.travis.yml\"><code class=\"language-yaml:title=.travis.yml\">language: node_js\nnode_js:\n  - &quot;10.9.0&quot;</code></pre></div>\n<p>This is the absolute least we can do for our CI pipeline, we’re telling Travis that we’re using node version 10.9.0. Note: I only chose 10.9.0 because it’s the latest stable version of Node available at the time of writing. To find out what version you’re on, type <code class=\"language-text\">node -v</code> in the command line and declare that version in your <code class=\"language-text\">.travis.yml</code> file. We don’t want any discrepancies between our development environment and our production build, so we’ll use keep the version of Node we’re using consistent.</p>\n<p>Once you’ve done this, commit your changes and push them forward. Travis should recognise your <code class=\"language-text\">.travis.yml</code> file and starts running the pipeline.</p>\n<p>You should be getting feedback from Travis about your builds, and that they’re failing. This is expected as by default, travis runs a <code class=\"language-text\">yarn test</code> as part of its pipeline. We have no tests so error code 1 is thrown causing the pipeline to fail. To get this passing, we’ll add a token test to our codebase. In <code class=\"language-text\">blog/src/pages</code> create a new file <code class=\"language-text\">blogitem.test.js</code> and add the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx:title=blogitem.test.js\"><pre class=\"language-jsx:title=blogitem.test.js\"><code class=\"language-jsx:title=blogitem.test.js\">import React from &quot;react&quot;\nimport { shallow } from &quot;enzyme&quot;\nimport BlogItem from &quot;./blogItem&quot;\n\ndescribe(&quot;Layout component&quot;, () =&gt; {\n  const mockProps = {\n    pathContext: {\n      data: {\n        title: &quot;mock title&quot;,\n        content: &quot;mock content&quot;,\n        href: &quot;google.com&quot;,\n      },\n    },\n  }\n\n  it(&quot;should render&quot;, () =&gt; {\n    const wrapper = shallow(&lt;BlogItem {...mockProps} /&gt;)\n\n    expect(wrapper)\n  })\n})</code></pre></div>\n<p>We’re using Enzyme, a package that lets us test React components by rendering the component in a virtual DOM. For the sake of the tutorial, we’re doing the enzyme equivalent of <code class=\"language-text\">expect(true).toBe(true)</code>. Now go into the <code class=\"language-text\">package.json</code> file for blog and add <code class=\"language-text\">jest test --config ../../jest-config.json</code> to the <code class=\"language-text\">test</code> field under <code class=\"language-text\">scripts</code>. Once you’ve done this, navigate to the blog package in the command line and run <code class=\"language-text\">yarn test</code>, your should test pass. Go ahead and do the same for shop package’s <code class=\"language-text\">shoppingItem</code> component.</p>\n<p>Note: you’ll likely need <code class=\"language-text\">react-router-dom</code> specified as a dependency to get the tests working. I elaborate more on this in the troubleshooting section below. Also make sure you’ve get <code class=\"language-text\">jest</code> installed globally, if not then run <code class=\"language-text\">yarn global add jest</code> in your command line. Test to see that <code class=\"language-text\">yarn build</code> still works for each package, as it’s going to be the next step in our pipeline.</p>\n<p>Before we push, we need to make a couple more changes to our pipeline. Update your <code class=\"language-text\">.travis.yml</code> file so it looks like the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml:title=.travis.yml\"><pre class=\"language-yaml:title=.travis.yml\"><code class=\"language-yaml:title=.travis.yml\">language: node_js\nnode_js:\n  - &quot;10.9.0&quot;\n\ncache: yarn\n\ninstall:\n  - yarn global add lerna jest\n  - lerna bootstrap\n\nscript:\n  - yarn test\n  - yarn build</code></pre></div>\n<p>The additions include caching Yarn, installing the global dependencies, and specifying that we want to run <code class=\"language-text\">yarn test</code> and <code class=\"language-text\">yarn build</code> as part of our pipeline.</p>\n<p>Run <code class=\"language-text\">yarn test</code> one last time in your command line to make sure that everything still works. If it does then push your code to kick off the CI pipeline. Keep Travis-CI open in your web browser so you can watch the feedback for each CI step. If Travis throws up a bunch of red all over your screen, then it looks like something’s gone wrong. If this is the case, try running everything locally to see if it still works. A common error is using a global package locally that we haven’t explicitly specified in our <code class=\"language-text\">.travis.yml</code> file. This means that Travis won’t have access to it when running the pipeline. Travis normally gives good logging to give clues as to why your pipeline failed, so it’s worth digging through them.</p>\n<p>There are two more sections we need to add to our <code class=\"language-text\">.travis.yml</code> file</p>\n<ul>\n<li>Handling the individual scripts for each package.</li>\n<li>Handling deployment when the pipeline passes.</li>\n</ul>\n<p>We won’t worry about the latter for now, but let’s deal with running scripts for different repos. Because we’re not going to be deploying our <code class=\"language-text\">shared-ui</code> we can skip it from our CI pipeline. We’ll run <code class=\"language-text\">yarn test</code> and <code class=\"language-text\">yarn build</code> for both the blog and the shop.</p>\n<p>We’ll do this by adding a <code class=\"language-text\">matrix</code> step right after the <code class=\"language-text\">install</code> step to the CI pipeline. This <code class=\"language-text\">matrix</code> step will let us specify which packages we want to run the CI pipeline on. We’ll name each matrix and set an environment variables for the package location. We’ll then change the <code class=\"language-text\">script</code> step so Travis moves into the correct directory and runs the <code class=\"language-text\">script</code> step. Delete everything after the <code class=\"language-text\">install</code> step and add the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml:title=.travis.yml\"><pre class=\"language-yaml:title=.travis.yml\"><code class=\"language-yaml:title=.travis.yml\">matrix:\n  include:\n    - name: &quot;Blog Pipeline&quot;\n      env: PACKAGE_LOCATION=packages/blog\n    - name: &quot;Shop Pipeline&quot;\n      env: PACKAGE_LOCATION=packages/shop\nscript:\n  - cd $PACKAGE_LOCATION\n  - yarn test\n  - yarn build</code></pre></div>\n<p>Hopefully what I’ve said makes more sense with the code in front of us. The <code class=\"language-text\">script</code> pipeline runs for each step we’ve included in the <code class=\"language-text\">matrix</code>. We’ve also added another step to the <code class=\"language-text\">script</code> section, this is doing nothing more than moving to the directory of the current package. Push the changes again to your repo and open Travis to see your pipeline running. You should now be seeing two build jobs running simultaneously, which means our matrix is working. If everything passes, we’ll move on to deploying our application.</p>\n<h3>Vercel</h3>\n<p>Vercel is a tool created by Vercel that makes the process of deploying Node applications simple. Vercel has recently released updates to the way they deploy static websites. Fortunately our Gatsby packages build to static sites, so it’s a win for us.</p>\n<p>If you haven’t used Vercel before, then go-ahead and <a href=\"https://vercel.com/home#features\">get started</a>. This will install the <code class=\"language-text\">Vercel CLI</code> and get a free account created, things we need for the tutorial. The getting started page also has a brief FAQs section that’s well worth reading.</p>\n<p>Travis-CI isn’t permitted to deploy to your Vercel account by default, and requires a token. You can create a token via the Account Settings page on the Vercel website. Once you’re there click the tokens tab and create a new token. Copy it to your clipboard, as we’ll be adding to the list of variables that Travis uses in our pipelines. Go to your lerna-monorepo repository in Travis and from the ‘More options’ drop down, click ‘settings’. When you’re here, you’ll see a section called ‘environment variables’. Create a new variable called <code class=\"language-text\">VERCEL_TOKEN</code> and paste your Vercel public key as the value. We can now reference the key from within our <code class=\"language-text\">.travis.yml</code> file.</p>\n<p>We’ll add the final part of our pipeline now, which deals with deployment. Make sure your <code class=\"language-text\">.travis.yml</code> file looks like the following, and we’ll run through the additions.</p>\n<div class=\"gatsby-highlight\" data-language=\"yaml:title=.travis.yml\"><pre class=\"language-yaml:title=.travis.yml\"><code class=\"language-yaml:title=.travis.yml\">language: node_js\nnode_js:\n  - &quot;10.9.0&quot;\n\ncache: yarn\n\ninstall:\n  - yarn global add lerna jest vercel\n  - lerna bootstrap\n\nmatrix:\n  include:\n    - name: Blog Pipeline\n      env: PACKAGE_LOCATION=packages/blog PACKAGE_NAME=lerna-monorepo-blog\n    - name: Shop Pipeline\n      env: PACKAGE_LOCATION=packages/shop PACKAGE_NAME=lerna-monorepo-shop\n\nscript:\n  - cd $PACKAGE_LOCATION\n  - yarn test\n  - yarn build\n\ndeploy:\n  provider: script\n  script: vercel public --token $VERCEL_TOKEN\n  skip_cleanup: true\n  app: $PACKAGE_NAME</code></pre></div>\n<p>Note that we’ve added some additional environment variables to our matrix so and them in there. There are huge changes we’ve made to the end of the file so let’s go through them line by line:</p>\n<ul>\n<li>deploy — specifies the step of the pipeline; the deployment step.</li>\n<li>provider — tells the name of the script to run for deployment, in this case it’s ‘script’</li>\n<li>skip_cleanup — we don’t want Travis to get rid of any files made during the build. We created the ‘public’ folder when running the build, so we don’t want Travis to get rid of it.</li>\n<li>app — specifies the name of the application we’re deploying,</li>\n</ul>\n<p>We have to do add a little bit of configuration on our side to ensure that Vercel hosts our sites correctly. The config comes in the form of a <code class=\"language-text\">vercel.json</code> file, which outlines the options we want Vercel to use when deploying our site. Go into the directory for our blog packages and create a <code class=\"language-text\">vercel.json</code> file. We want to let Vercel know that we’re deploying a static site, the entry directory to the static site, and what alias we want to assign our site. Put this inside your <code class=\"language-text\">vercel.json</code> file.</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=vercel.json\"><pre class=\"language-json:title=vercel.json\"><code class=\"language-json:title=vercel.json\">{\n  &quot;type&quot;: &quot;static&quot;,\n  &quot;alias&quot;: &quot;lerna-monorepo-blog&quot;,\n  &quot;static&quot;: {\n    &quot;public&quot;: &quot;public&quot;\n  },\n  &quot;public&quot;: true,\n  &quot;version&quot;: 1\n}</code></pre></div>\n<p>Note: <code class=\"language-text\">public: true</code> needs to be specified since you’ll most likely have a free Vercel account. Having a publicly facing site is one of the restrictions of the free tier. The entry file to our static site is also called <code class=\"language-text\">public</code> so don’t conflate the two.</p>\n<p>Push these changes to your repo to kick off your build pipeline. If everything was successful then your build will have passed and your site will have deployed. Go to Travis, open up your blog build so you have access to the logs. Scroll right to the bottom to where it says ‘deploying application’ and uncollapse the section. This’ll be the URL that Vercel deployed your site to. It should look something like <code class=\"language-text\">https://buildsjdoe383jd.vercel.app</code>. Copy that url and go back to your command line. Run the following command:</p>\n<p><code class=\"language-text\">vercel alias &lt;your randomly generated URL&gt; &lt;your chosen alias&gt;</code>\nI chose ‘lerna-monorepo-blog’ as my alias, so that one won’t be available for you to use, so choose your own. When you’ve run the command, there will be feedback saying that the alias was successfully created. If not, then it’s likely the command was written incorrectly or the alias is already in use by someone else. Once you’ve added an alias successfully for the blog, do the same for your shop package.</p>\n<p>Even if you push everything forward now the site’s navigation will still be broken. The very last thing we need to do is add our alias URL as an environment variables in our <code class=\"language-text\">.env.production</code> file. In your blog package’s <code class=\"language-text\">.env.production</code> go ahead and add the following:</p>\n<p><code class=\"language-text\">BLOG_URL=https://&lt;your chosen alias&gt;.vercel.app/</code></p>\n<p>Do the same for your shop url, commit and push. Congrats!</p>\n<h3>Thanks for reading!</h3>\n<p>You should now be able to access the site and navigate easily between your shop and your blog. Great job!</p>\n<p>If you enjoyed the article or have any questions, please reach out to me on <a href=\"https://twitter.com/andricokaroulla?lang=en\">Twitter</a>!</p>\n<p>You can find a variety of JavaScript related articles <a href=\"https://medium.com/@andricokaroulla\">here</a></p>\n<p>I’m also running a <a href=\"https://www.eventbrite.com/e/gatsbyjs-workshop-develop-and-deploy-your-own-blog-tickets-52432622385?aff=GatsbyBlog\">Gatsby workshop</a> in London, February 2019.</p>\n<h3>Troubleshooting</h3>\n<p>I’ll be adding to this section as I get feedback or stumble across issues myself.</p>\n<p>If you get an error that says <code class=\"language-text\">lerna: command not found</code> after installing it globally, then install it locally as a project dependency and run it using <code class=\"language-text\">yarn lerna &lt;command&gt;</code>.</p>\n<p>Running your application:</p>\n<p>A lot can go wrong in the first half of the application, so make sure that your files sit in their correct place. Also check you’re importing from the <code class=\"language-text\">shared-ui</code> package correctly.</p>\n<p>My first go to when the application doesn’t work as expected is to run <code class=\"language-text\">lerna clean</code> and <code class=\"language-text\">lerna bootstrap</code>. This clears all of your <code class=\"language-text\">node_modules</code> and reinstalls them.</p>\n<p>You need <code class=\"language-text\">react</code> specified in the package level <code class=\"language-text\">package.json</code> file to run your application. And you’ll also need <code class=\"language-text\">react</code> and <code class=\"language-text\">react-router-dom</code> specified in the top-level <code class=\"language-text\">package.json</code> to run the tests. This left me stumped, and the only logical reason why I think this happens is because Gatsby only seems to look for React in the package level <code class=\"language-text\">node_modules</code> directory, Since the tests are run from the top level, React also needs to exist there.</p>\n<p>My suggestion would be to have the package level react dependency the latest version of React, while the top-level react dependency as version 16.0.0.</p>\n<p>Running the pipeline for your application:</p>\n<p>If your CI pipeline isn’t deploying your site correctly, it can be difficult to distinguish whether or not it’s an issue with Travis or an issue with Vercel. If you can navigate to one of your package directory and run now, and everything’s successful, then it’s likely an issue with your <code class=\"language-text\">.travis.yml</code> file or the way in which your defining your environment variables in Travis. Go over that section one more time to make sure you’ve got it all written as it should be.</p>\n<p>Deploying your application:</p>\n<p>If running the now command in your package throws an error, then make sure you’re logged in to Vercel via the CLI. You can do this via Vercel login. Make sure that your <code class=\"language-text\">vercel.json</code> file points to the correct output of yarn build. It may be your version of Gatsby doesn’t create a build directory called <code class=\"language-text\">public</code> but instead <code class=\"language-text\">dist</code> or <code class=\"language-text\">build</code>.</p>\n<p>Viewing your live application:</p>\n<p>Chances are that you might need to deploy your site more than once before everything works, lord knows I did when writing this application. One thing that tripped me up was client-side caching. Which is something that Vercel does out of the box. It just means that even if you’ve deployed a new version of the site, you might be viewing an older, cached version. If this is the case, open the Chrome/browser dev tools, right-click the reload symbol, and click ‘empty cache and hard reload’.</p>","frontmatter":{"title":"Publish Multiple Gatsby Sites in a Monorepo, Using Lerna, Travis & Vercel","date":"January 01, 2019","description":null}}},"pageContext":{"slug":"/docs/blog/2019-01-01-publish-multiple-gatsby-sites/","previous":{"fields":{"slug":"/docs/blog/2018-12-31-how-we-do-high-impact-ux-research/"},"frontmatter":{"title":"How Gatsby does high-impact, low-effort UX research (and you can too!)"}},"next":{"fields":{"slug":"/docs/blog/2018-12-19-gatsby-scales-with-expertise-and-scope/"},"frontmatter":{"title":"How Gatsby scales with your expertise & scope"}}}}}