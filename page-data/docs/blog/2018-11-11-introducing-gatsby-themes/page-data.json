{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2018-11-11-introducing-gatsby-themes/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"3414623c-edbc-510b-9c07-be2e272ba160","excerpt":"Gatsby is a powerful platform for building marketing sites, blogs,\ne-commerce frontends, and more. You can source data from static files\nand any number of…","html":"<p>Gatsby is a powerful platform for building marketing sites, blogs,\ne-commerce frontends, and more. You can source data from static files\nand any number of content management systems. You can process images,\nadd support for our favorite styling technique, transform markdown,\nand just about anything else you can imagine.</p>\n<p>At its core, a Gatsby site is a combination of functionality centered\naround a single config file, <code class=\"language-text\">gatsby-config.js</code>. This config file\ncontrols an assortment of site metadata, data type mapping, and most\nimportantly, plugins. Plugins contain large amounts of customizable\nfunctionality for turning markdown into pages, processing components\ninto documentation, and even processing images.</p>\n<h2>Scaling Gatsby</h2>\n<p>Creating a single Gatsby site works super well. The power of\n<code class=\"language-text\">gatsby-config.js</code>, plugins, and more coalesce to make the experience a\nbreeze. However, what if you want to re-use this configuration on our\nnext site? Sure, you could clone a boilerplate each time, but that gets\nold, quickly. Wouldn’t it be great if you could re-use our\ngatsby-config.js across projects? That’s where starters come in.</p>\n<h3>Improving Reusability with Starters</h3>\n<p>One way to create more sites with similar functionality faster is to\nuse starters. Starters are basically whole Gatsby sites that can be\nscaffolded through the gatsby CLI. This helps you start your project\nby cloning the boilerplate, installing dependencies, and clearing Git\nhistory. The community around Gatsby has built a lot of different\nstarters for various use cases including blogging, working with\nmaterial design, and documentation.</p>\n<p>The problem with starters is that they’re one-offs. Starters are\nboilerplate projects that begin to diverge immediately from upstream\nand have no easy way of updating when changes are made\nupstream. There’s another approach to boilerplate that has become\npopular in recent years that fixes some problems with the boilerplate\napproach such as updating with upstream. One such project is\n<a href=\"https://facebook.github.io/create-react-app/\"><code class=\"language-text\">create-react-app</code></a>. In\nthe Gatsby world, you can improve on starters similarly with themes.</p>\n<h3>Truly Reusable Themes in Gatsby</h3>\n<p>If a single <code class=\"language-text\">gatsby-config.js</code> encodes the functionality of a whole Gatsby\nsite, then if you can\n<a href=\"https://medium.com/javascript-scene/master-the-javascript-interview-what-is-function-composition-20dfb109a1a0\">compose</a>\nthe <code class=\"language-text\">gatsby-config.js</code> data structure together you have the base for\nthemes. You can encode portions of our gatsby-config as themes and\nre-use them across sites. This is a big deal because you can have a\ntheme config (or multiple configs) that composes together with the\ncustom config (for the current site). Upgrading the underlying theme\ndoes not undo the customizations, meaning you get upstream\nimprovements to the theme without a difficult manual upgrade process.</p>\n<h2>Why Themes?</h2>\n<p>Defining themes as the base composition unit of Gatsby sites allows us to start\nsolving a variety of use cases. For example, when a site gets built as\npart of a wider product offering it’s often the case that one team\nwill build out a suite of functionality, including branding elements,\nand the other teams will mostly consume this functionality. Themes\nallow us to distribute this functionality as an npm package and allow\nthe customization of various branding elements through our\n<code class=\"language-text\">gatsby-config.js</code>.</p>\n<h2>Mechanics of Theming</h2>\n<p>At a base level, theming combines the <code class=\"language-text\">gatsby-config.js</code> of the\ntheme with the <code class=\"language-text\">gatsby-config.js</code> of your site. Since it’s an experimental\nfeature, you use an experimental namespace to declare themes in\nthe config.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  plugins<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      resolve<span class=\"token operator\">:</span> <span class=\"token string\">\"gatsby-theme-blog\"</span><span class=\"token punctuation\">,</span>\n      options<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Themes often need to be parameterized for various reasons, such as\nchanging the base url for subsections of a site or applying branding\nvariables. You can do this through the theme options if you define our\ntheme’s gatsby-config as a function that returns an object.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  plugins<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      resolve<span class=\"token operator\">:</span> <span class=\"token string\">\"gatsby-theme-blog\"</span><span class=\"token punctuation\">,</span>\n      options<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        some<span class=\"token operator\">:</span> <span class=\"token string\">\"value\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Themes also function as plugins and any config passed into the theme\nin your <code class=\"language-text\">gatsby-config.js</code> will also be passed to your theme’s <code class=\"language-text\">gatsby-*.js</code>\nfiles as plugin options. This allows themes to override any settings\ninherited from the theme’s own plugin declarations or apply gatsby\nlifecycle hooks such as <a href=\"/gatsby-bloga-2/docs/node-apis/#onCreatePage\"><code class=\"language-text\">onCreatePage</code></a>.</p>\n<p>Check out the theme examples in this multi-package repo for more\nexamples of using and building themes: <a href=\"https://github.com/ChristopherBiscardi/gatsby-theme-examples\">https://github.com/ChristopherBiscardi/gatsby-theme-examples</a>.</p>\n<h2>Next Steps</h2>\n<h3>Sub Themes and Overriding</h3>\n<p>This is just the first step and it enables us to experiment with\nfurther improvements in userland before merging them into\ncore. Sub-theming, for example, is a critical part of a theming\necosystem that is currently missing from Gatsby. Overriding theme\nelements is possible on a coarse level right now in userland. If, for\nexample, a theme defines a set of pages using\n<a href=\"/gatsby-bloga-2/docs/actions/#createPage\"><code class=\"language-text\">createPage</code></a> you can define a helper\nfunction that will look for the page component first in the user’s\nsite and then fall back to the theme’s default implementation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">withThemePath</span> <span class=\"token operator\">=</span> <span class=\"token parameter\">relativePath</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> pathResolvedPath <span class=\"token operator\">=</span> path<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>relativePath<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">let</span> finalPath <span class=\"token operator\">=</span> pathResolvedPath\n\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// check if the user's site has the file</span>\n    require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>pathResolvedPath<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// if the user hasn't implemented the file,</span>\n    finalPath <span class=\"token operator\">=</span> require<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>relativePath<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> finalPath\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Then in our theme’s <code class=\"language-text\">createPage</code> call, you simply use the helper to let\nthe user optionally override the default component.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">createPage({\n  path: post.node.fields.slug,\n  component: withThemePath(&quot;./src/templates/blog-post.js&quot;),\n})</code></pre></div>\n<p>This doesn’t allow us to make more granular overrides of different\ncomponents, but it does allow us to replace the rendering of pages and\nother whole elements. Component Shadowing, a more granular method of\noverriding, is already in the works.</p>\n<p>If you want to be involved in the development of theming for Gatsby,\njoin the Spectrum community for <a href=\"https://spectrum.chat/gatsby-themes/general?thread=1e02db45-9f2e-4c0a-b42e-a4d4e4d519a8\">Gatsby\nthemes</a>.</p>\n<p>I’ll also be talking about theming Gatsby at <a href=\"https://www.eventbrite.com/e/gatsby-days-tickets-51837151315\">Gatsby\nDays</a> on\nDec 7th covering how Gatsby got here and where theming is going next.</p>","frontmatter":{"title":"Introducing Gatsby Themes","date":"November 11, 2018","description":null}}},"pageContext":{"slug":"/docs/blog/2018-11-11-introducing-gatsby-themes/","previous":{"fields":{"slug":"/docs/blog/2018-11-07-gatsby-for-apps/"},"frontmatter":{"title":"Gatsby for Apps"}},"next":{"fields":{"slug":"/docs/blog/2018-11-16-youfit-case-study/"},"frontmatter":{"title":"Youfit uses Gatsby to increase lead generation by 60%"}}}}}