{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2019-06-12-performance-improvements-for-large-sites/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"c5446da4-c51c-5670-bbec-b0907ef0da08","excerpt":"Gatsby has always been, and will always be, focused on performance. All of the best practices and patterns relating to performance are internalized and we…","html":"<p>Gatsby has always been, and will always be, focused on performance. All of the best practices and patterns relating to performance are internalized and we enable these performance optimizations <em>by default</em> for every Gatsby application. However, there is always more we can do and we are always striving to make incremental improvements that impact <em>every</em> Gatsby user. From this basis, we’re happy to announce a new performance improvement: splitting the page manifest into individual files for each page. Prior to this change, for large Gatsby applications (e.g. more than 5,000 pages), the page manifest could grow to 200Kb or more, and loading this manifest could take several seconds on 3G connections, which is certainly non-ideal!</p>\n<p>Over the past few months, I’ve been gradually changing Gatsby’s architecture so that the size of the site has absolutely no impact on real-world performance. This change <a href=\"https://github.com/gatsbyjs/gatsby/pull/14359#event-2402986461\">has been merged</a> and is available, for free, in <a href=\"https://www.npmjs.com/package/gatsby/v/2.9.0\">Gatsby v2.9.0</a>. From this point forward, your application manifest will no longer grow proportionally to the number of pages in your Gatsby application.</p>\n<p>In this post, I’ll dive deep into the technical intricacies of what was actually causing this slow down and how we fixed the growing page manifest problem.</p>\n<h2>Symptoms</h2>\n<p>There were two main symptoms experienced by users of large Gatsby sites.</p>\n<ol>\n<li>After navigating to a Gatsby site, it took a while for all the JavaScript to load so that it was “interactive”. Therefore, clicks immediately after loading the page could take many seconds to actually navigate.</li>\n<li>Even after the initial load, clicking links could be somewhat laggy even though the target’s resources had already been pre-fetched.</li>\n</ol>\n<h2>The Problem: Global pages manifest</h2>\n<p>The central problem was that Gatsby generates a file for each build called <code class=\"language-text\">pages-manifest.json</code> (also called <code class=\"language-text\">data.json</code>) that must be loaded by the browser before users can navigate to other pages. It contains metadata about every page on the site, including:</p>\n<ul>\n<li><strong>componentChunkName</strong>: The logical name of the React component for the page</li>\n<li><strong>dataPath</strong>: The path to the file that contains the page’s GraphQL query result, and any other page context.</li>\n</ul>\n<p>When a user clicks a link to another page, Gatsby first looks up the manifest for the page’s component and query result file. Gatsby then downloads them (if they haven’t already been prefetched), and then passes the loaded query results to the page’s component and renders it. Since <code class=\"language-text\">pages-manifest</code> contains the list of all pages on the site, Gatsby can also immediately show a 404 if necessary if the page is not able to be located.</p>\n<p>This works great for small sites, but as a Gatsby application grows, so too does the size of the page manifest. The bigger the manifest gets the more data the browser has to download before any UI navigation can occur leading to slowdowns in important metrics like Time to Interactive (TTI).</p>\n<p>Even after the manifest had been loaded, the manifest had to be searched for the matching path. This was necessary since pages can be declared with a <a href=\"https://www.gatsbyjs.org/docs/gatsby-internals-terminology/#matchpath\">matchPath</a> (a Regular Expression used to match client-only paths). Huge manifest files resulted in perceptable lag when clicking links too!</p>\n<h2>Solution: Eliminate the monolithic pages manifest!</h2>\n<p>The solution seems abundantly obvious at this point. We needed to introduce a manifest file per page, instead of a global pages-manifest. We called this <code class=\"language-text\">page-data.json</code>. It includes:</p>\n<ul>\n<li><strong>componentChunkName</strong>: The logical name of the React component for the page</li>\n<li><strong>result</strong>: The full GraphQL query result and page context</li>\n<li><strong>webpackCompilationHash</strong>: Unique hash output by webpack any time user’s <code class=\"language-text\">src</code> code content changes</li>\n</ul>\n<p>This is very similar to each entry in the pages manifest. The major difference being that the GraphQL query result is inlined instead of being contained in a separate file.</p>\n<p>Now, when a page navigation occurs, Gatsby makes a request directly to the server for the <code class=\"language-text\">page-data.json</code>, instead of checking the global manifest (which doesn’t exist anymore).</p>\n<p>Below is a <a href=\"https://www.webpagetest.org/\">webpagetest.org</a> comparison of <a href=\"https://www.gatsbyjs.org/\">gatsbyjs.org</a> (which has about 2,500 pages) <a href=\"https://www.webpagetest.org/result/190530_4Y_26c37e9fa44cdeef1617d2861ee6927e/\">before</a> and <a href=\"https://www.webpagetest.org/result/190530_7J_5f0c238b0658ed9de9aa7ed30b5538e6/\">after</a> the change. As you can see, the <em>First Interactive</em> has been reduced by 432% (5.011 seconds saved), and almost all other metrics have improved as well.</p>\n<figure>\n  <span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/37c35/comparison.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 17.567567567567565%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAw0lEQVQY0z1Qx6qFUBDz/7/HnTvLRizYXQsqVuwVzCUD7x0YkslkAnOUfd/R9z2GYZAiZ3Vdh7ZtUde1cGJZlnBdF6ZpSum6jiAIEMcxDMOAZVlQiqIQk+/7iKIIjuPAtm1ZIGqahjzPoaqqBIRhiDRNkWWZ7HmeJ4HUkiSBMk0T1nXFPM84jgPLsuA8T2zbhvu+BfnoIW+aRuac8YKqqmTveR6M4wiFQwo8nSbidV2i/QV+3/fv4bdQf99XOEOZwZ6BP5D3JmrDJXaJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"Webpagetest.org performance comparison\" title=\"Webpagetest.org performance comparison\" src=\"/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/fcda8/comparison.png\" srcset=\"/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/12f09/comparison.png 148w,\n/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/e4a3f/comparison.png 295w,\n/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/fcda8/comparison.png 590w,\n/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/efc66/comparison.png 885w,\n/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/c83ae/comparison.png 1180w,\n/gatsby-bloga-2/static/bd7d414f16473cdd3c09fbbe908e8fc2/37c35/comparison.png 1810w\" sizes=\"(max-width: 590px) 100vw, 590px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\">\n  </a>\n    </span>\n  <figcaption>\n    Webpagetest.org Comparison of Gatsbyjs.org before and after v2.9.0\n  </figcaption>\n</figure>\n<h3>Don’t we have to wait on a network request on each navigation now?</h3>\n<p>Prefetching FTW! Gatsby already prefetches any links on the page so that when the browser needs them, they’re already in the cache. So when Gatsby makes a request for the <code class=\"language-text\">page-data.json</code>, it’s already in the browser (assuming the user has been on the page long enough for the prefetches to finish). You can read more about this prefetching behavior in this blog <a href=\"/gatsby-bloga-2/blog/2019-04-02-behind-the-scenes-what-makes-gatsby-great/#gatsby-link-and-link-relprefetch\">deep dive on Gatsby’s performance optimizations</a>.</p>\n<h2>Other benefits</h2>\n<h3>Gatsby sites are now more “live”</h3>\n<p>Previously in Gatsby, all resources are content-hashed (except the HTML files). This includes the pages-manifest. So once a Gatsby site is loaded in the browser, the user will only ever see the resources generated during that build. If they stay on the site for days, they’ll never see new content until they refresh.</p>\n<p>The new <code class=\"language-text\">page-data.json</code> resources are <strong>not</strong> content-hashed. This means that if a user is on the site and a rebuild occurs resulting in changed <code class=\"language-text\">page-data.json</code>, the user will then see that new information when they navigate to that page.</p>\n<p>However, this is only true if a page hasn’t already been prefetched. We have some ideas for periodically expiring prefetched data to ensure that new changes are visible to users. Stay tuned for more on this front!</p>\n<h3>Netlify builds faster</h3>\n<p>The old GraphQL static query results were content-hashed. Which meant that any change to any data resulted in a change to the pages-manifest. Hosting sites such as Netlify look at the changed files and use that to figure out what files can be shared between builds. Since the pages-manifest depends on all query result files, which are all content-hashed, then any data change resulted in a change to the pages-manifest, which could be 10+ MB in size.</p>\n<p>With the latest changes, if you only make a change one page’s data, then Netlify will only have to copy that file when it rebuilds.</p>\n<h3>First step towards incremental builds</h3>\n<p>Gatsby has been talking about incremental builds <a href=\"/gatsby-bloga-2/blog/2018-05-24-launching-new-gatsby-company/#rebuild-gatsby-on-a-stream-processing-architecture-to-eliminate-the-build-step\">since day one</a>. The pages-manifest was a global list of all pages that was tied to webpack. So any change to any page data resulted in a full webpack rebuild. This directly opens up the opportunity to deliver a feature like incremental builds, and we can’t wait to do just that.</p>\n<h2>Backwards compatible</h2>\n<p>To use these changes, simply update to the latest version of Gatsby. All changes are 100% backwards compatible. One of the key values of using Gatsby and keeping up-to-date is that we are regularly making these incremental improvements that you can deliver to your users just by upgrading your version of Gatsby. Upgrade to Gatsby v2.9.x today—and keep those Gatsby applications blazing fast 🔥!</p>","frontmatter":{"title":"Performance improvements for large sites","date":"June 12, 2019","description":null}}},"pageContext":{"slug":"/docs/blog/2019-06-12-performance-improvements-for-large-sites/","previous":{"fields":{"slug":"/docs/blog/2019-06-10-how-to-recognize-when-gatsby-is-a-good-fit-for-your-client/"},"frontmatter":{"title":"How To Recognize When Gatsby is a Good Fit for Your Client"}},"next":{"fields":{"slug":"/docs/blog/2019-06-17-site-showcase-validator/"},"frontmatter":{"title":"Maintaining the Site Showcase with GitHub Actions and the Gatsby Site Showcase Validator"}}}}}