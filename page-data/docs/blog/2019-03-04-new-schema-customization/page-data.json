{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2019-03-04-new-schema-customization/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"9535368e-3343-58e1-95ba-5833aa085de1","excerpt":"Today we are releasing a preview of a new core Gatsby API - Schema Customization. It gives Gatsby users much better control over the inferred schema, solving…","html":"<p>Today we are releasing a preview of a new core Gatsby API - Schema Customization. It gives Gatsby users much better control over the inferred schema, solving many common issues that people have had with their data sources. In addition to adding the new API, we rewrote big chunks of schema generation code from scratch. This gives us a great long-term foundation that will let us make Gatsby GraphQL better in the future.</p>\n<p>I would like to thank our community member <a href=\"https://github.com/stefanprobst\">Stefan Probst</a>, who not only did lots of initial groundwork on the refactoring, but also helped immensely with the follow-up work there. We are really happy to have such a great community and super grateful to Stefan for all his hard work. I’d also like to thank <a href=\"https://github.com/nodkz/\">Pavel Chertorogov</a>, the author of the <a href=\"https://graphql-compose.github.io/\">graphql-compose</a> library that we used, who’s been super responsive to our bug reports and feature requests.</p>\n<p>As it’s a huge feature and big parts of the code are affected, we are releasing it as an alpha preview. You can try it by adding <code class=\"language-text\">gatsby@schema-customization</code> as a dependency for your Gatsby site.</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">npm</span> <span class=\"token function\">install</span> gatsby@schema-customization</code></pre></div>\n<p>We would really appreciate your help in surfacing any bugs in this code, so we encourage you to try it and report any issues that you encounter in <a href=\"https://github.com/gatsbyjs/gatsby/issues/12272\">this pinned issue</a>. If you want to contribute to fixing some of those bugs, open PRs against <a href=\"https://github.com/gatsbyjs/gatsby/pull/11480\">this branch</a>.</p>\n<h2>Why was it needed?</h2>\n<p>The motivation to do this change is a two-fold one. Before this feature, Gatsby automatically generated a GraphQL schema for your site based on the data available from your source plugins. While this schema inference is great for getting started it has also been the cause of many problems.</p>\n<p>Automatically generating schemas mean that changing your data can result in a changed schema. An updated schema may no longer work with the queries you’ve written, resulting in errors and confusion. Making schema generation smarter is just pouring more oil on an already burning fire. The core issue is not the inference, but lack of control. Therefore we wanted to give people control over the schema.</p>\n<p>On the other hand, we wanted to reevaluate our approach to schemas in general. In the “wild”, GraphQL is used very differently than in Gatsby. Schemas aren’t as commonly generated from the data sources and often schemas are the source of truth. We want to experiment with enabling people to use that approach with Gatsby too. By allowing people to define types and resolvers, we open new opportunities in that direction. We want to see how the community reacts to these changes and if that will evolve into new approaches to defining schemas in Gatsby.</p>\n<h2>New API</h2>\n<p>There are two main additions to the API:</p>\n<ol>\n<li>A <code class=\"language-text\">createTypes</code> action that allows one to add, extend or fix the types by passing their type definition using <a href=\"https://graphql.org/learn/schema/\">GraphQL SDL</a>.</li>\n<li>A <code class=\"language-text\">createResolvers</code> <a href=\"/gatsby-bloga-2/docs/node-apis/\">Gatsby Node API</a> that can add or override resolvers on any types and fields in the schema. It can also add new fields with such resolvers.</li>\n</ol>\n<p>Why the two APIs? <code class=\"language-text\">createTypes</code> primary purpose is to <em>fix</em> the definition for an automatically generated Node type. Often one is totally happy with the default resolvers that Gatsby provides and the only issue is that inference can change based on data changes.</p>\n<p>On the other hand, <code class=\"language-text\">createResolvers</code> is to add <em>extra functionality</em> to types. <code class=\"language-text\">createResolvers</code> also allows adding new <em>root fields</em> to Query type.</p>\n<h3><code class=\"language-text\">createTypes</code></h3>\n<p>Let’s consider an example with <code class=\"language-text\">gatsby-source-filesystem</code>, where we are loading data from an <code class=\"language-text\">authors.json</code> file. It has the following contents:</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=authors.json\"><pre class=\"language-json:title=authors.json\"><code class=\"language-json:title=authors.json\">[\n  {\n    &quot;name&quot;: &quot;Mikhail Novikov&quot;,\n    &quot;birthday&quot;: &quot;1987-09-25&quot;\n  }\n]</code></pre></div>\n<p>This would be inferred in Gatsby as a Node type with a Date type for birthday.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorsJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># default gatsby node fields</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">parent</span><span class=\"token punctuation\">:</span> Node\n  <span class=\"token attr-name\">children</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>Node<span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">internal</span><span class=\"token punctuation\">:</span> `Internal`<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\"># inferred fields</span>\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> String\n  <span class=\"token attr-name\">birthday</span><span class=\"token punctuation\">:</span> Date\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>However this can break if we accidentally add an invalid date as a birthday for a new node.</p>\n<div class=\"gatsby-highlight\" data-language=\"json:title=authors.json\"><pre class=\"language-json:title=authors.json\"><code class=\"language-json:title=authors.json\">[\n  {\n    &quot;name&quot;: &quot;Mikhail Novikov&quot;,\n    &quot;birthday&quot;: &quot;1987-09-25&quot;\n  },\n  {\n    &quot;name&quot;: &quot;Stefan Probst&quot;,\n    &quot;birthday&quot;: &quot;Unknown&quot;\n  }\n]</code></pre></div>\n<p>Now there is a type conflict between date and string and this will be inferred as string, possibly breaking our queries.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorsJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># default gatsby node fields</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">parent</span><span class=\"token punctuation\">:</span> Node\n  <span class=\"token attr-name\">children</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>Node<span class=\"token operator\">!</span><span class=\"token punctuation\">]</span><span class=\"token operator\">!</span>\n  <span class=\"token attr-name\">internal</span><span class=\"token punctuation\">:</span> `Internal<span class=\"token operator\">!</span>`<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\"># inferred fields</span>\n  <span class=\"token attr-name\">name</span><span class=\"token punctuation\">:</span> String\n  <span class=\"token attr-name\">birthday</span><span class=\"token punctuation\">:</span> String\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Luckily, now we can use the <code class=\"language-text\">createTypes</code> action to force birthday to be a Date.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">exports<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">sourceNodes</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> actions <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> createTypes <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> actions\n  <span class=\"token keyword\">const</span> typeDefs <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">\n    # One must say that the type is a Node\n    type AuthorJson implements Node {\n      # However Node fields are optional and you don't have to add them\n      name: String\n      birthday: Date\n    }\n  </span><span class=\"token template-punctuation string\">`</span></span>\n  <span class=\"token function\">createTypes</span><span class=\"token punctuation\">(</span>typeDefs<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Gatsby will now know that you want a Date and not override it with a string.</p>\n<p>You can specify types for some or all of the fields that you have on the given node type. Gatsby will add missing fields. This behavior can be controlled with <code class=\"language-text\">@infer</code> and <code class=\"language-text\">@dontInfer</code> directives.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token comment\"># For this type `name` won't be added</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token directive function\">@dontInfer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">birthday</span><span class=\"token punctuation\">:</span> Date\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># For this type `name` won't be added but `birthday` won't get a Gatsby resolver for date formatting</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token directive function\">@dontInfer</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">noDefaultResolvers</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">birthday</span><span class=\"token punctuation\">:</span> Date\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># For this type both `name` and `birthday` fields will be added. Current default behavior, but allows one to be explicit about it.</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token directive function\">@infer</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\"># `birthday` will be Date, but we won't add a Gatsby resolver for date formatting</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">AuthorJson</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Node</span> <span class=\"token directive function\">@infer</span><span class=\"token punctuation\">(</span><span class=\"token attr-name\">noDefaultResolvers</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token attr-name\">id</span><span class=\"token punctuation\">:</span> ID<span class=\"token operator\">!</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3><code class=\"language-text\">createResolvers</code></h3>\n<p>This is a similar API to <code class=\"language-text\">setFieldsOnGraphQLNodeType</code> in that it allows you to add new fields and resolvers to types. However, this one is run last, so you’d have the entire schema available to be augmented. It is also possible to extend the <code class=\"language-text\">Query</code> type to add custom root resolvers, which enables a powerful resolver-based approach to querying your data sources. <code class=\"language-text\">createResolvers</code> is called after third-party schemas are merged (e.g. ones added by <code class=\"language-text\">gatsby-source-graphql</code>), so you can extend those schemas too.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">exports.createResolvers = ({ createResolvers, schema }) =&gt; {\n  createResolvers({\n    AuthorJson: {\n      // Modify birthday resolver so that it uses 1970-01-01 as default date\n      birthday: {\n        resolve(source, args, context, info) {\n          // original resolver available as &quot;info.originalResolver&quot;\n          if (Number.isNaN(new Date(source[&quot;birthday&quot;]))) {\n            return info.originalResolver(\n              {\n                ...source,\n                birthday: &quot;1970-01-01&quot;,\n              },\n              args,\n              context,\n              info\n            )\n          } else {\n            return info.originalResolver(source, args, context, info)\n          }\n        },\n      },\n    },\n  })\n}</code></pre></div>\n<p>It’s also possible to create new root fields, for example one that will return all author names as strings.</p>\n<div class=\"gatsby-highlight\" data-language=\"js:title=gatsby-node.js\"><pre class=\"language-js:title=gatsby-node.js\"><code class=\"language-js:title=gatsby-node.js\">createResolvers({\n  Query: {\n    allAuthorFullNames: {\n      type: `[String!]!`,\n      resolve(source, args, context, info) {\n        const authors = context.nodeModel.getAllNodes({\n          type: `AuthorJson`,\n        })\n        return authors.map(author =&gt; author.name)\n      },\n    },\n  },\n})</code></pre></div>\n<p>Notice the <code class=\"language-text\">context.nodeModel</code>. We expose our internal node storage to the resolvers, so that one can fetch data from there. In addition to lower level access functions (<code class=\"language-text\">getNodeById</code>, <code class=\"language-text\">getAllNodes</code>), full node querying is available in <code class=\"language-text\">runQuery</code>.</p>\n<p>You can also see <a href=\"https://github.com/gatsbyjs/gatsby/tree/master/examples/using-type-definitions\">using-type-definitions example</a> in the Gatsby repository.</p>\n<h2>Other niceties</h2>\n<p>Refactoring the schema generation allowed us to fix some related long-standing bugs and issues.</p>\n<h3>Type Names</h3>\n<p>Previously, type names were generated with names like <code class=\"language-text\">internal_2</code> or <code class=\"language-text\">SomeType_2</code>, which can be extremely confusing. We’ve normalized all the names, so that these additional suffixes are no longer necessary. If you have relied on generated names as above, this branch will break for you. However, we never considered these types to be part our public API, partially because of the above issue. By making this change we can now assert that the naming of the types should be stable.</p>\n<h3>Connection <code class=\"language-text\">nodes</code> field</h3>\n<p>Querying connections is pretty verbose in Gatsby.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  allMarkdownRemark <span class=\"token punctuation\">{</span>\n    edges <span class=\"token punctuation\">{</span>\n      node <span class=\"token punctuation\">{</span>\n        id\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>When you have many connections, this becomes pretty tedious, especially destructuring it all in JS. We’ve added a very common shortcut <code class=\"language-text\">nodes</code> that allows you to not write <code class=\"language-text\">{ edges { node }}</code>, but directly resolves an array of nodes instead.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  allMarkdownRemark <span class=\"token punctuation\">{</span>\n    nodes <span class=\"token punctuation\">{</span>\n      id\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3>Inference quirks</h3>\n<p>We’ve had some quirks in inference that were dependent on ordering. We’ve made all inference deterministic.</p>\n<ol>\n<li>Mix of date and non-date strings is always a string</li>\n<li>Conflicting field names always prefer Node references first and then the canonical name of the field.</li>\n</ol>\n<h2>How did we do it?</h2>\n<p>The biggest issue with building GraphQL schemas with <code class=\"language-text\">graphql-js</code> is that <code class=\"language-text\">graphql-js</code> expects all types to be final at the moment where either the schema is created or one inspects the fields of the type. This is solved in <code class=\"language-text\">graphql-js</code> by using <em>thunks</em>, non-argument functions that refer to types in some global context. With hand-written schemas usually there are type definitions in the same file as the newly defined type, but this isn’t available in a generated schema situation.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> graphql<span class=\"token punctuation\">.</span><span class=\"token function\">GraphQLObjectType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"Foo\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">fields</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">graphql<span class=\"token punctuation\">.</span>GraphQLNonNull</span><span class=\"token punctuation\">(</span>graphql<span class=\"token punctuation\">.</span>GraphQLID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Must be an actual reference to that type</span>\n      type<span class=\"token operator\">:</span> Bar<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>To solve these issues, a pattern called <em>Type Registry</em> has been widely used. A type registry is an abstraction that holds types inside it and allows other types to retrieve them.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// some global state type registry</span>\n<span class=\"token keyword\">const</span> TypeRegistry <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"./typeRegistry\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> graphql<span class=\"token punctuation\">.</span><span class=\"token function\">GraphQLObjectType</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"Foo\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">fields</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      type<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">graphql<span class=\"token punctuation\">.</span>GraphQLNonNull</span><span class=\"token punctuation\">(</span>graphql<span class=\"token punctuation\">.</span>GraphQLID<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Allows referring to types by their string names</span>\n      type<span class=\"token operator\">:</span> TypeRegistry<span class=\"token punctuation\">.</span><span class=\"token function\">getType</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>After all types are collected into the type registry, the registry can be converted to a normal GraphQL schema. Other common features include being able to generate types like input objects and filter from the types held in the type registry.</p>\n<p>We didn’t want to implement a type registry and all the related parts ourselves. Thankfully, there is a library just for that - <a href=\"https://graphql-compose.github.io/\">graphql-compose</a>. We opted to use it and it saved us lots of time. I really recommend this library to anyone, especially if you plan to generate types.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// global schema composer</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> SchemaComposer <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"graphql-compose\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">const</span> Foo <span class=\"token operator\">=</span> SchemaComposer<span class=\"token punctuation\">.</span>TypeComposer<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n  name<span class=\"token operator\">:</span> <span class=\"token string\">\"Foo\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token function-variable function\">fields</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// types can be strings</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'ID!'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    bar<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Allows referring to types by their string names</span>\n      type<span class=\"token operator\">:</span> <span class=\"token string\">'Bar'</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>The final schema pipeline that we implemented works like this:</p>\n<ol>\n<li>We collect all types that are created with <code class=\"language-text\">createTypes</code> and add them to the compose type registry (called <em>Schema Composer</em>)</li>\n<li>We go through all the collected nodes and we infer types for them</li>\n<li>We merge user defined types with inferred types and add them to the composer</li>\n<li>We add default resolvers for type fields, such as for <code class=\"language-text\">File</code> and <code class=\"language-text\">Date</code> fields</li>\n<li><code class=\"language-text\">setFieldsOnNodeType</code> is called and those fields are added to the types</li>\n<li>We create derived input objects, such as filter and sort and then create pagination types such as Connections</li>\n<li>Root level resolvers are created for all node types</li>\n<li>Third-party schemas are merged into the Gatsby schema</li>\n<li>The <code class=\"language-text\">createResolvers</code> API is called and resulting resolvers are added to the schema</li>\n<li>We generate the schema</li>\n</ol>\n<p>You can see the <code class=\"language-text\">packages/gatsby/schema/</code> folder in the <a href=\"https://github.com/gatsbyjs/gatsby/pull/11480\">schema refactoring PR</a> to learn more about the code.</p>\n<h2>Further work</h2>\n<p>These schema changes are a first step. In the future we want to add more control over the schema and more access to our internal APIs to our users. Our next step would be to add explicit types to the plugins that we maintain. We also want to let those plugins expose their internal APIs through the Model layer, like we did for our root Node API. This way one can reuse the functionality that is only available in plugins in their own resolvers.</p>\n<p>We are super excited about those changes. As I mentioned, we really encourage you to try it by adding <code class=\"language-text\">gatsby@schema-customization</code> as a dependency to your Gatsby application. Send us feedback in <a href=\"https://github.com/gatsbyjs/gatsby/issues/12272\">this issue</a>. We can’t wait to hear your feedback on this new, core functionality and see all the great apps and functionality it allows you to build.</p>","frontmatter":{"title":"New schema customization API in Gatsby","date":"March 04, 2019","description":null}}},"pageContext":{"slug":"/docs/blog/2019-03-04-new-schema-customization/","previous":{"fields":{"slug":"/docs/blog/2019-03-01-localization-with-gatsby-and-sanity/"},"frontmatter":{"title":"A method for Localization with Gatsby and Sanity.io"}},"next":{"fields":{"slug":"/docs/blog/2019-03-05-dot-org-messaging-survey/"},"frontmatter":{"title":"Results from .org messaging survey are in"}}}}}