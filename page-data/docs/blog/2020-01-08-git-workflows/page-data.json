{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2020-01-08-git-workflows/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"f1e7e7e5-875d-544d-bdb7-bb9daf62ab53","excerpt":"import Breakout from “@components/breakout”\nimport VisuallyHidden from “@components/visually-hidden”\nimport baseGithub from “./base-github.png”\nimport…","html":"<p>import Breakout from “@components/breakout”\nimport VisuallyHidden from “@components/visually-hidden”\nimport baseGithub from “./base-github.png”\nimport initialSvg from “./1-initial.svg”\nimport additionalWorkSvg from “./2-additional-work.svg”\nimport rebasedSvg from “./3-rebased.svg”\nimport mergeSrc from “./merge.png”\nimport mergeCommitSvg from “./4-merge-commit.svg”\nimport actualGitSvg from “./6-actual-git.svg”\nimport parallelUniversesSvg from “./7-parallel-universes.svg”\nimport doubleWorkSvg from “./8-double-work.svg”\nimport moreIncrementalSvg from “./5-more-incremental.svg”</p>\n<p>2020 is shaping up to be a really exciting year for Gatsby, with lots of ambitious projects on the roadmap. On the Gatsby Cloud team, we’ve been getting all of our ducks in a row, making sure we’re all set to hit the ground running. One of the areas we’ve been focusing on is our GitHub workflow.</p>\n<p>We were seeing a lot of “stalled” Pull Requests (PRs) - work was being put up for review, but not receiving prompt attention. These PRs tended to be quite large and complex, essentially containing the entirety of work for a given feature or refactor.</p>\n<p>Monolithic PRs are difficult to review. In addition to the time investment, they also tend to require a lot of mental energy; to be an effective reviewer, you need to build up a mental picture of the change, and the larger that change is, the more context needs to be held in focus. Additionally, large PRs tend to develop their own inertia. If a reviewer has a great idea for an alternative approach, but it would require scrapping most of the work already done in the PR, it’s not likely to be acted upon (if it’s even shared in the first place).</p>\n<p>It’s easy to say that developers should limit the size of their PRs, but this is very much easier said than done. GitHub really doesn’t make it clear or intuitive how to break work up into multiple reviewable units. PRs are based on branches, and it’s not always clear how to juggle multiple branches. Even for folks who are comfortable with Git, the path can be very tricky.</p>\n<p>Ideally, the developer could spin up new PRs as they went, allowing them to solicit feedback early, without being blocked while waiting for it. If the feedback <em>does</em> require significant changes, it should be easy to integrate those changes into their more-recent work.</p>\n<p>This blog post explains how we solved for these concerns!</p>\n<h2>Workflow overview</h2>\n<p>Let’s say we’re working on a blog, and want to incorporate a headless CMS, switching from using local markdown files and hardcoded data.</p>\n<p>First, we create a new branch, <code class=\"language-text\">feat/headless-cms</code>. This will be our <em>root branch</em>; we’ll merge PRs as we go into this branch. We never commit to it directly, and so for the time being, it’s a clone of our <em>deploy branch</em> (typically master or staging, whichever branch features are typically merged into). Even though it doesn’t hold any commits yet, we should push it to GitHub.</p>\n<p>Right after creating that branch and pushing it to GitHub, we create another branch, <code class=\"language-text\">feat/headless-cms-pt1</code>. This will be an <em>incremental branch</em>, holding some of the changes needed for this feature. We get to work on the most fundamental parts of this change (for example, adding a source plugin and configuring it to pull data from our new CMS). Once we have a “hello world” based on this new architecture, we’re ready to solicit some feedback. We push our branch to GitHub, and open a PR comparing our <em>incremental</em> branch to our <em>root</em> branch:</p>\n<p><img\n  src={baseGithub}\n  alt=\"A screenshot from GitHub showing that the PR is opened against 'feat/headless-cms' instead of master.\"\n/></p>\n<p>In a traditional workflow, opening a PR makes it hard for us to keep working on that feature; we’ll bloat the PR if we keep committing to it, and it’s not obvious how to manage “chained” PRs. This is a big part of why teams wind up with big PRs.</p>\n<p>In this alternative workflow, we can keep working. We’ll create a new <em>incremental branch</em>, <code class=\"language-text\">feat/headless-cms-pt2</code>, forked from <code class=\"language-text\">feat/headless-cms-pt1</code>.</p>\n<p>Here’s a visualization of this setup:</p>\n<Breakout>\n  <img src={initialSvg} aria-describedby=\"git-setup-description\" />\n</Breakout>\n<VisuallyHidden id=\"git-setup-description\">\n  4 git branches are represented with parallel lines. Our root branch,\n  feat/headless-cms, is forked from staging, and contains no commits.\n  feat/headless-cms-pt1 is forked from our root branch, and includes two\n  commits, A and B. Finally, a fourth branch, feat/headless-cms-pt2, is forked\n  after commit B, and includes one commit, C.\n</VisuallyHidden>\n<p>Our first incremental branch has two commits, <code class=\"language-text\">A</code> and <code class=\"language-text\">B</code>. Our second branch is forked from that first branch, and adds a new commit <code class=\"language-text\">C</code>.</p>\n<h3>When changes are requested</h3>\n<p>At first blush, this workflow might seem problematic to you. How can you start work on the second part of the feature before getting feedback on the first? What if a bunch of changes are requested?</p>\n<p>In fact, this workflow shines when it comes to implementing requested changes.</p>\n<p>Let’s say that we get feedback that fundamentally changes how we want to approach it. It requires a good amount of restructuring. We do those changes, and create a new commit, <code class=\"language-text\">D</code>, on our <code class=\"language-text\">pt1</code> branch:</p>\n<Breakout>\n  <img src={additionalWorkSvg} aria-describedby=\"git-additional-work\" />\n</Breakout>\n<VisuallyHidden id=\"git-additional-work\">\n  4 parallel lines are shown, representing different branches: staging,\n  feat/headless-cms, feat/headless-cms-pt1, and feat/headless-cms-pt2. As it was\n  before, commits A and B are on our \"pt1\" branch, and commit C is on our \"pt2\"\n  branch. A newly-added commit, D, is on our \"pt1\" branch, but it occurs after\n  the fork that leads to commit C on the later feature branch.\n</VisuallyHidden>\n<p>Our <code class=\"language-text\">pt1</code> PR is approved (🎉), but now we have to reconcile our <code class=\"language-text\">pt2</code> branch. Given that it built on a now-outdated structure, there’s a good chance we’ll have some conflicts.</p>\n<p>We check out the <code class=\"language-text\">pt2</code> branch and rebase it onto the updated <code class=\"language-text\">pt1</code> branch:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> checkout feat/headless-cms-pt2\n<span class=\"token function\">git</span> rebase feat/headless-cms-pt1</code></pre></div>\n<p>If you’re not familiar with rebasing, it’s an alternative to merging that involves “replaying” commits over a different branch. This can be a weird idea for folks who are used to merging, and it takes most people a bit of practice to get comfortable with it. You can learn more about rebasing in <a href=\"https://blog.algolia.com/master-git-rebase/\">this article from Algolia</a>.</p>\n<h3>Conflicts</h3>\n<p>After running that rebase command, we’ll likely get a conflict, since our commit <code class=\"language-text\">C</code> is incompatible with the changes in <code class=\"language-text\">D</code>. Here’s the cool thing, though: the conflicts <em>show us exactly what needs to change</em>.</p>\n<p>For many, Git conflicts are a stressful experience, one to be avoided at all costs. In this case, though, conflicts are actually pretty helpful, because they give you targeted information about the problem.</p>\n<p>Imagine if we had instead opened one big PR with all of our changes. We’d get the same feedback: fundamental restructuring requested. Now it’s on us, the developer, to figure out which parts of this big PR need to change, and which parts can stay the same. We need to do the work of hunting down the conflicts.</p>\n<p>In this alternative flow, we’re <em>leveraging</em> Git to show us what work needs to be done.</p>\n<p>Once we’ve fixed all the conflicts, we can finish up our rebase by running the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># stage all the changes we just made</span>\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n\n<span class=\"token comment\"># wrap up the rebase</span>\n<span class=\"token function\">git</span> rebase --continue</code></pre></div>\n<p>After rebasing, our Git branches look like this:</p>\n<Breakout>\n  <img src={rebasedSvg} aria-describedby=\"git-rebased\" />\n</Breakout>\n<VisuallyHidden id=\"git-rebased\">\n  4 parallel lines are shown, representing different branches: staging,\n  feat/headless-cms, feat/headless-cms-pt1, and feat/headless-cms-pt2. Our \"pt1\"\n  branch now holds commits A, B, D in series, with the split to \"pt2\" happening\n  later. After the split, commit E is added on the \"pt2\" branch.\n</VisuallyHidden>\n<p>You’ll notice that our <code class=\"language-text\">C</code> commit—the only commit in our <code class=\"language-text\">pt2</code> branch—has been replaced with <code class=\"language-text\">E</code>. This is because it’s no longer the same commit; it includes the changes that we dealt with in our rebase.</p>\n<p>Because we’ve rewritten the history, by turning <code class=\"language-text\">C</code> into <code class=\"language-text\">E</code>, we need to force-push to update our PR on GitHub:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> push origin feat/headless-cms-pt2 -f</code></pre></div>\n<h3>Merging PRs</h3>\n<p>When PRs are approved, we can merge them. We have a couple options in this flow:</p>\n<ul>\n<li>Merge from the last one down (merge <code class=\"language-text\">pt2</code> into <code class=\"language-text\">pt1</code>, and then <code class=\"language-text\">pt1</code> into the root branch)</li>\n<li>Merge from the first one up (merge <code class=\"language-text\">pt1</code> into the root branch, and then merge <code class=\"language-text\">pt2</code> into the root branch)</li>\n</ul>\n<p>In general, the second strategy is better, because it’s more flexible; you don’t need to wait for all work to be done before you can start merging!</p>\n<p>We’ll start by merging <code class=\"language-text\">pt1</code> into the root branch. Merge it in using the standard “Create a merge commit” option:</p>\n<p><img\n  src={mergeSrc}\n  alt=\"The GitHub pull request screen shows a 'merge' button with a dropdown and several options. This screenshot highlights that the first option is the desired one, 'Create a merge commit'.\"\n/></p>\n<p>Next, we need to update our <code class=\"language-text\">pt2</code> branch. Right now it’s still being compared to <code class=\"language-text\">pt1</code>, a branch which has since been merged. We want to point it to our <em>root</em> branch, <code class=\"language-text\">feat/headless-cms</code>, instead.</p>\n<p>We can do this on GitHub by <em>changing the base</em>. GitHub has <a href=\"https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/changing-the-base-branch-of-a-pull-request\">great docs</a> that cover this. In effect, it allows us to switch which branch we want to merge our changes into.</p>\n<p>With our new base set, our tree looks like this:</p>\n<Breakout>\n  <img src={mergeCommitSvg} aria-describedby=\"git-merge-commit\" />\n</Breakout>\n<VisuallyHidden id=\"git-merge-commit\">\n  3 parallel lines are shown, representing different branches: staging,\n  feat/headless-cms, and feat/headless-cms-pt2. Our \"pt1\" branch is not\n  pictured. Our root branch, \"feat/headless-cms\", holds commits A, B, D, and M.\n  After that last commit, the branch is split into \"pt2\", which holds commit E.\n</VisuallyHidden>\n<p>A new commit <code class=\"language-text\">M</code> was added, representing the merge.</p>\n<h3>🙅‍♀️ No squashing 🙅‍♀️</h3>\n<p>It’s important that we stick with the default “Create a merge commit” option, in the short term. Before merging our changes into master, we’ll be able to squash everything into 1 commit, but for now, preserving the history is important, in order for Git to correctly track what’s happening.</p>\n<p>When branches are visualized, they’re often depicted as groups of commits. This very blog post is guilty of this as well: in the above diagram, our root branch is shown as “containing” commits <code class=\"language-text\">A</code>, <code class=\"language-text\">B</code>, and <code class=\"language-text\">D</code>.</p>\n<p>In fact, branches are much thinner abstractions than that; all they do is point towards a specific commit. This works because commits themselves are similar to a linked list; every commit also points to its parent commit.</p>\n<p>A more accurate representation of our current state would look like this:</p>\n<Breakout>\n  <img src={actualGitSvg} alt=\"\" aria-describedby=\"git-actual\" />\n</Breakout>\n<VisuallyHidden id=\"git-actual\">\n  Unlike the previous visualizations, which featured multiple parallel lines\n  each holding commits, this new representation shows a single chain of commits:\n  A, B, D, M, E. At the start of the chain, it points to the previous commits\n  from the original branch (staging). Commit M is circled and is annotated with\n  the branch name, feat/headless-cms. Commit E is also circled, with the\n  annotation feat/headless-cms-pt2. In this representation, branches are simply\n  labels applied to individual commits, which form a long, single chain.\n</VisuallyHidden>\n<p>Every commit points to its parent, and branches are just references to a particular commit.</p>\n<p>Let’s say we had squash-merged our <code class=\"language-text\">pt1</code> branch into the root branch. We would wind up with two <em>parallel universes</em>. In our root branch, we’d have a brand new commit <code class=\"language-text\">S</code>, representing the squashed contents of <code class=\"language-text\">pt1</code>. Our <code class=\"language-text\">pt2</code> branch, meanwhile, doesn’t know about any of this; the chain of commits still includes the “unsquashed” <code class=\"language-text\">pt1</code> work.</p>\n<Breakout>\n  <img\n    src={parallelUniversesSvg}\n    alt=\"\"\n    aria-describedby=\"git-parallel-universes\"\n  />\n</Breakout>\n<VisuallyHidden id=\"git-parallel-universes\">\n  This image is split into two halves. The top half is labeled \"Universe 1:\n  feat/headless-cms-pt2\", and it shows the string of commits that the\n  feat/headless-cms-pt2 branch points to: A, B, D, M, E. This is the same chain\n  as in the previous image. The second half shows a different chain. It's\n  labeled \"Universe 2: feat/headless-cms\", and shows the chain of commits held\n  by our root branch: S, E.\n</VisuallyHidden>\n<p>These universes collide when we try to change the base, to point <code class=\"language-text\">pt2</code> at the root branch:</p>\n<Breakout>\n  <img src={doubleWorkSvg} alt=\"\" aria-describedby=\"git-double-work\" />\n</Breakout>\n<VisuallyHidden id=\"git-double-work\">\n  This image shows the string of commits that occurs when changing the base. The\n  string of commits is: S, A, B, D, M, E. The first commit is circled with the\n  label \"Part 1\", since it includes the work contained in the \"pt1\" branch.\n  Commits A, B, D, and M are circled as well, with the label \"Also Part 1\". This\n  image demonstrates the problem: that the same work is repeated twice in the\n  history.\n</VisuallyHidden>\n<p>The Git history pollution isn’t a huge deal, since we’ll have the chance to squash or clean this up before deploying, but it can lead to weird issues and nonsensical conflicts.</p>\n<p>If you do wind up squash-merging a branch, you’ll need to manually snip out the duplicate commits. You can do this with an <a href=\"https://hackernoon.com/beginners-guide-to-interactive-rebasing-346a3f9c3a6d\">interactive rebase</a>:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> checkout feat/headless-cms-pt2\n<span class=\"token function\">git</span> rebase -i feat/headless-cms\n<span class=\"token comment\"># A popup will open, presenting you with a list of commits.</span>\n<span class=\"token comment\"># Delete the lines that contain work covered by the squashed</span>\n<span class=\"token comment\"># commit. Save and close the file.</span></code></pre></div>\n<h3>Incorporating external changes</h3>\n<p>The work we’re doing in this example to migrate to a headless CMS might take a week or two. In that time, other folks at the org will undoubtedly be shipping a bunch of other stuff. We may wish to update our feature to incorporate those changes!</p>\n<p>To accomplish this, we’ll do some more local rebasing:</p>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># Update our local state</span>\n<span class=\"token function\">git</span> checkout master\n<span class=\"token function\">git</span> pull origin master\n\n<span class=\"token comment\"># Rebase our root branch</span>\n<span class=\"token function\">git</span> checkout feat/headless-cms\n<span class=\"token function\">git</span> rebase master\n\n<span class=\"token comment\"># Continue down the chain</span>\n<span class=\"token function\">git</span> checkout feat/headless-cms-pt2\n<span class=\"token function\">git</span> rebase feat/headless-cms</code></pre></div>\n<p>Essentially, we’re scooting all of our changes to happen <em>after</em> the most recent commit on master. It’s important to rebase instead of merge so that we don’t “interleave” the changes from other branches—we’re keeping all of our work tightly clustered for now. This can be a bit tedious if you have lots of incremental branches, so you may wish to hold off on this until you’ve merged everything into the root branch.</p>\n<h2>And on and on</h2>\n<p>The neat thing about this flow is that it isn’t limited to two incremental branches; we can keep going!</p>\n<p>In this example, we could check out a new branch, <code class=\"language-text\">pt3</code>, based off of <code class=\"language-text\">pt2</code>. And then a fourth, <code class=\"language-text\">pt4</code>, from <code class=\"language-text\">pt3</code>:</p>\n<Breakout>\n  <img src={moreIncrementalSvg} alt=\"\" aria-describedby=\"git-on-and-on\" />\n</Breakout>\n<VisuallyHidden id=\"git-on-and-on\">\n  Back in the parallel tracks world-view, we now have 5 parallel lines, each\n  representing different branches: staging, feat/headless-cms,\n  feat/headless-cms-pt2, feat/headless-cms-pt3, and feat/headless-cms-pt4. The\n  root branch holds A, B, D, and M, which is then split to \"pt2\", which holds E.\n  Another split leads to branch \"pt3, which holds the commit F, before finally\n  splitting into \"pt4\", which holds the last commit in this image, G.\n</VisuallyHidden>\n<p>No matter how many branches we have, the process is always the same when we’re ready to start merging:</p>\n<ul>\n<li>Merge the earliest open PR into the root branch, using the standard “merge” option.</li>\n<li><em>Change the base</em> of the next branch to point at the root branch</li>\n</ul>\n<h2>Ship it</h2>\n<p>What about when all the work is done, and we’re ready to release?</p>\n<p>At this point, we’ll have a string of commits on our root branch, <code class=\"language-text\">feat/headless-cms</code>. We can open a PR against our deploy branch (e.g. master or staging). Because all the work has already been reviewed, we don’t need to go through another review cycle.</p>\n<p>At this point, we have the freedom to organize our commits however we want. We can squash it all into 1 commit, or combine them into logical chunks. It’s up to us to decide how we want our work to be reflected in the history.</p>\n<h2>Drawbacks</h2>\n<p>No flow is without tradeoffs, and this one has a couple:</p>\n<h3>1. It rewrites history</h3>\n<p>This flow relies heavily on rebasing, which rewrites history. This means that pushing to GitHub requires a force-push, which can be scary, especially for folks newer to using Git.</p>\n<p>This also makes it harder to collaborate on a feature; you need to communicate clearly before rebasing, to make sure everyone’s work is in beforehand.</p>\n<h3>2. It involves some branch juggling</h3>\n<p>With 3-4 incremental branches, developers have to bounce between them and make sure they’re kept in sync. This can be tedious.</p>\n<h2>When should I use this flow?</h2>\n<p>Given the drawbacks mentioned above, this is probably not something that should be adopted for <em>every</em> change. It provides the most benefit for changes that are too big to fit into a single PR.</p>\n<p>It’s hard to define a “big” PR - sometimes, a PR changes 2,000 lines of code, but only because a codemod slightly tweaked a bunch of files. Other times, a 300-line PR is so dense that it could benefit from being broken up into smaller pieces.</p>\n<p>The amount of time it takes to <em>review</em> a PR is often correlated with the amount of time it took to <em>write</em> it, so maybe a better rule of thumb is that a PR is too big if it encompasses more than a few days’ worth of development effort.</p>\n<p>It’s also worth mentioning that feature flags are a viable alternative to this flow. Feature flags are toggles that can be flipped, and read from within the codebase. This means that unfinished work can be merged into production as long as it’s hidden behind a feature flag. Once all the changes have been merged, the flag can be flipped, and the feature will be enabled.</p>\n<p>Feature flags are great because they allow developers to break monolithic changes into smaller PRs, but sometimes the cost of architecting a change to fit behind a feature flag is more trouble than it’s worth (e.g. sprawling changes that affect many different parts of the codebase, or large refactors).</p>\n<p>When using feature flags, a streamlined version of this flow can still be useful, to ensure that developers aren’t blocked while waiting for feedback.</p>\n<h2>Conclusion</h2>\n<p>We’ve been using this flow on the Cloud team for a few weeks now, and it’s been a pretty big boon to our productivity! PRs are tailored to be easy to review, and developers don’t have to switch tasks to avoid being blocked while awaiting feedback. It’s pretty great.</p>\n<p>Parts of this flow can be tedious, as the same commands need to be repeated over and over again to update multiple incremental branches. It might be interesting to explore some additional tooling, to manage this for us! But in the meantime, it’s a small price to pay.</p>\n<p>If you give this flow a shot, I’d love to hear how it works for you! Feel free to <a href=\"https://twitter.com/JoshWComeau\">reach out on Twitter</a>.</p>","frontmatter":{"title":"Incremental PRs: a new GitHub workflow for the Gatsby Cloud team","date":"January 30, 2020","description":null}}},"pageContext":{"slug":"/docs/blog/2020-01-08-git-workflows/","previous":{"fields":{"slug":"/docs/blog/2020-01-30-why-gatsby-is-better-with-javascript/"},"frontmatter":{"title":"Why Gatsby is better with JavaScript"}},"next":{"fields":{"slug":"/docs/blog/100days/serverless/"},"frontmatter":{"title":"Challenge 6 - Use Serverless Functions and Services to Collect Form Data"}}}}}