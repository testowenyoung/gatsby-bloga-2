{"componentChunkName":"component---src-templates-blog-post-js","path":"/docs/blog/2018-09-25-announcing-graphql-stitching-support/","result":{"data":{"site":{"siteMetadata":{"title":"Gatsby Starter Blog"}},"markdownRemark":{"id":"53c59e90-3590-54c5-97b2-c206b196031c","excerpt":"When Gatsby was started 3.5 years ago, GraphQL was still an internal project at Facebook and had yet to be open sourced. Since being open sourced, GraphQL’s…","html":"<p>When Gatsby was started 3.5 years ago, <a href=\"https://www.graphql.com/\">GraphQL</a> was still an internal project at Facebook and had yet to be open sourced.</p>\n<p>Since being open sourced, GraphQL’s usage has exploded and <a href=\"https://www.graphql.com/case-studies/\">1000s of companies use it to power critical apps and websites</a>.</p>\n<p>Gatsby’s vision is to be the integration layer for modern websites gluing together data and code into highly performant websites and apps. GraphQL is integral to this vision.</p>\n<p>Gatsby v1 shipped last year with a plugin-powered data layer that let you easily pull data from any source using GraphQL. At the time, there was still very few public GraphQL schemas so we built a system that let plugins transform data from REST APIs into a GraphQL schema.</p>\n<p>But in the last year, a lot has changed. More and more services are shipping with native GraphQL APIs. CMSs like <a href=\"https://graphcms.com/\">GraphCMS</a>, <a href=\"https://aws.amazon.com/appsync/\">AppSync</a>, and <a href=\"https://www.takeshape.io/\">TakeShape</a> all have launched GraphQL APIs. <a href=\"https://www.contentful.com/\">Contentful</a> is launching a <a href=\"https://www.contentful.com/blog/2018/07/04/graphql-abstract-syntax-tree-new-schema/\">native GraphQL API as well soon</a>.</p>\n<p>Watching the spread of GraphQL has all been incredibly exciting to watch and a fulfillment of our vision for the future of the web where sites easily stitch together data from many sources.</p>\n<p>But unfortunately, these new GraphQL APIs have been awkward to use inside Gatsby as you first had to wrap the API inside a Gatsby source plugin before you could query the data from your components.</p>\n<p>To fix this, <a href=\"/gatsby-bloga-2/blog/2018-09-17-gatsby-v2/\">Gatsby 2.0</a> adds experimental support for schema stitching of external GraphQL APIs to its internal schema. Schema stitching allows merging multiple GraphQL schemas together, which greatly simplifies working with third-party GraphQL APIs. Along with low-level support for stitching in general, we are shipping an official <a href=\"/gatsby-bloga-2/packages/gatsby-source-graphql/\">gatsby-source-graphql</a> plugin, which enables connecting to an arbitrary GraphQL API with just a few lines of configuration!</p>\n<h2>Getting started</h2>\n<p>Gatsby’s data model is powered by an internal GraphQL API. It is a great abstraction that allows you to define the data requirements of your app, be it some files in the filesystem or a third-party API.</p>\n<p>Previously, when you wanted to add a 3rd-party GraphQL API, you needed to write a custom source plugin. But now, you simply add a small bit of config to your site’s gatsby-config.js. The following example adds the Star Wars GraphQL API:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// In your gatsby-config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  plugins<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span>\n      resolve<span class=\"token operator\">:</span> <span class=\"token string\">\"gatsby-source-graphql\"</span><span class=\"token punctuation\">,</span>\n      options<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// This type will contain the remote schema Query type</span>\n        typeName<span class=\"token operator\">:</span> <span class=\"token string\">\"SWAPI\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// This is the field under which it's accessible</span>\n        fieldName<span class=\"token operator\">:</span> <span class=\"token string\">\"swapi\"</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">// URL to query from</span>\n        url<span class=\"token operator\">:</span> <span class=\"token string\">\"https://api.graphcms.com/simple/v1/swapi\"</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>After this you will have a field named <code class=\"language-text\">swapi</code> in your Gatsby GraphQL and you can query it.</p>\n<div class=\"gatsby-highlight\" data-language=\"graphql\"><pre class=\"language-graphql\"><code class=\"language-graphql\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\"># Field name parameter defines how you can access third party API</span>\n  swapi <span class=\"token punctuation\">{</span>\n    allSpecies <span class=\"token punctuation\">{</span>\n      name\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\"># Other Gatsby querying works normally</span>\n  site <span class=\"token punctuation\">{</span>\n    siteMetadata <span class=\"token punctuation\">{</span>\n      siteName\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2>Why is it needed?</h2>\n<p>To understand why a separate new plugin is needed, let’s dive into how Gatsby source plugins work. Gatsby’s GraphQL schema can be extended with source plugins. Source plugins can extend the schema by adding <em>nodes</em> - objects that have some kind of global id. This way a <code class=\"language-text\">gatsby-source-filesystem</code> plugin can add all the files from a directory as nodes. Gatsby introspects the nodes that it gets and creates a GraphQL schema which you can use to fetch all those nodes.</p>\n<p>This system works really well for many cases and it’s very intuitive, you don’t need to care about creating a GraphQL schema or types for the nodes, any objects can be used. However, this is a limitation when using existing GraphQL APIs. First of all, you won’t be able to use the same API as the one provided by the third-party API, because it will be replaced by Gatsby’s internal node API. This can be confusing, because you can’t consult the third-party API’s documentation. Secondly, the plugin needs to proactively fetch all the possible data from the API, which can be complicated because the plugin author would have to predict which data might be needed.</p>\n<p>When there weren’t many existing GraphQL APIs in the wild, that wasn’t that much of a problem. For the few available APIs there was a source plugin. With the rise of both public GraphQL APIs, like GitHub or Shopify, and with so many more people having a GraphQL API of their own (or using one of the GraphQL solutions like Prisma, GraphCMS or AppSync), writing a plugin for each one became unfeasible. Meet <code class=\"language-text\">gatsby-source-graphql</code>.</p>\n<h2>How does it work?</h2>\n<p>Instead of creating nodes for all potential items in a third-party API, <code class=\"language-text\">gatsby-source-graphql</code> uses schema stitching to combine the schema of a third-party API with the Gatsby schema. Schema stitching combines multiple GraphQL schemas into one, <a href=\"https://www.apollographql.com/docs/graphql-tools/schema-stitching.html\">read more about it here</a>.</p>\n<p>The plugin puts the full third-party GraphQL API under one field in Gatsby’s API. This way any types or fields of that API can be queried. There is no need to prefetch that data beforehand to create nodes, because the data will be fetched on-demand as required by the page queries.</p>\n<p>The actual stitching happens on the Gatsby level. There is a new action, <a href=\"/gatsby-bloga-2/docs/actions/#addThirdPartySchema\"><code class=\"language-text\">addThirdPartySchema</code></a>, that can be used to add arbitrary schemas for stitching. It’s a deliberately low-level API that we hope other plugin authors can use in the future to implement some mind-blowing GraphQL functionality.</p>\n<h2>Conclusions</h2>\n<p><code class=\"language-text\">gatsby-source-graphql</code> is part of <a href=\"/gatsby-bloga-2/blog/2018-09-17-gatsby-v2/\">Gatsby’s 2.0 release</a>. Try it out now! <a href=\"/gatsby-bloga-2/docs/third-party-graphql\">Check out the docs</a> or <a href=\"https://github.com/freiksenet/gatsby-github-displayer\">a sample project using GitHub’s GraphQL API</a>.</p>","frontmatter":{"title":"Announcing support for natively querying 3rd-party GraphQL APIs with Gatsby","date":"September 25, 2018","description":null}}},"pageContext":{"slug":"/docs/blog/2018-09-25-announcing-graphql-stitching-support/","previous":{"fields":{"slug":"/docs/blog/2018-09-21-lullabot-podcast/"},"frontmatter":{"title":"Listen to this Gatsby interview on the Lullabot podcast"}},"next":{"fields":{"slug":"/docs/blog/2018-09-27-reach-router/"},"frontmatter":{"title":"How we improved Gatsby's accessibility in v2 by switching to @reach/router"}}}}}